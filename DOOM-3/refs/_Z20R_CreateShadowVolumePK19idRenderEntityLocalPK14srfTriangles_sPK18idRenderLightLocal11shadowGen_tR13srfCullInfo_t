<dec f='codebrowser/renderer/tr_local.h' l='1405' type='srfTriangles_t * R_CreateShadowVolume(const idRenderEntityLocal * ent, const srfTriangles_t * tri, const idRenderLightLocal * light, shadowGen_t optimize, srfCullInfo_t &amp; cullInfo)'/>
<use f='codebrowser/renderer/Interaction.cpp' l='914' u='c' c='_ZN13idInteraction17CreateInteractionEPK13idRenderModel'/>
<def f='codebrowser/renderer/tr_stencilshadow.cpp' l='1217' ll='1395' type='srfTriangles_t * R_CreateShadowVolume(const idRenderEntityLocal * ent, const srfTriangles_t * tri, const idRenderLightLocal * light, shadowGen_t optimize, srfCullInfo_t &amp; cullInfo)'/>
<doc f='codebrowser/renderer/tr_stencilshadow.cpp' l='1191'>/*
=================
R_CreateShadowVolume

The returned surface will have a valid bounds and radius for culling.

Triangles are clipped to the light frustum before projecting.

A single triangle can clip to as many as 7 vertexes, so
the worst case expansion is 2*(numindexes/3)*7 verts when counting both
the front and back caps, although it will usually only be a modest
increase in vertexes for closed modesl

The worst case index count is much larger, when the 7 vertex clipped triangle
needs 15 indexes for the front, 15 for the back, and 42 (a quad on seven sides)
for the sides, for a total of 72 indexes from the original 3.  Ouch.

NULL may be returned if the surface doesn&apos;t create a shadow volume at all,
as with a single face that the light is behind.

If an edge is within an epsilon of the border of the volume, it must be treated
as if it is clipped for triangles, generating a new sil edge, and act
as if it was culled for edges, because the sil edge will have been
generated by the triangle irregardless of if it actually was a sil edge.
=================
*/</doc>
<use f='codebrowser/tools/compilers/dmap/shadowopt3.cpp' l='1262' u='c' c='_Z17CreateLightShadowP15optimizeGroup_sPK10mapLight_t'/>
<use f='codebrowser/tools/compilers/dmap/shadowopt3.cpp' l='1264' u='c' c='_Z17CreateLightShadowP15optimizeGroup_sPK10mapLight_t'/>
