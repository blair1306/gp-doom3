<!doctype html>
<html>
<head>
<meta name="viewport" content="width=device-width, initial-scale=1.0"><title>urldata.h source code [codebrowser/curl/lib/urldata.h] - Woboq Code Browser</title>
<meta name="woboq:interestingDefinitions" content="ConnectBits,Curl_transfer_keeper,DynamicStatic,FILEPROTO,FTP,HTTP,Progress,PureInfo,SessionHandle,UrlState,UserDefined,back,connectdata,curl_ssl_session,digestdata,dynamically_allocated_data,ntlmdata,ssl_config_data,ssl_connect_data "/>
<link rel="stylesheet" href="../../../../data/qtcreator.css" title="QtCreator"/>
<link rel="alternate stylesheet" href="../../../../data/kdevelop.css" title="KDevelop"/>
<script type="text/javascript" src="../../../../data/jquery/jquery.min.js"></script>
<script type="text/javascript" src="../../../../data/jquery/jquery-ui.min.js"></script>
<script>var file = 'codebrowser/curl/lib/urldata.h'; var root_path = '../../..'; var data_path = '../../../../data';</script>
<script src='../../../../data/codebrowser.js'></script>
</head>
<body><div id='header'><h1 id='breadcrumb'><span>Browse the source code of </span><a href='../..'>codebrowser</a>/<a href='..'>curl</a>/<a href='./'>lib</a>/<a href='urldata.h.html'>urldata.h</a></h1></div>
<hr/><div id='content'><table class="code">
<tr><th id="1">1</th><td><u>#<span data-ppcond="1">ifndef</span> <span class="macro" data-ref="_M/__URLDATA_H">__URLDATA_H</span></u></td></tr>
<tr><th id="2">2</th><td><u>#define <dfn class="macro" id="_M/__URLDATA_H" data-ref="_M/__URLDATA_H">__URLDATA_H</dfn></u></td></tr>
<tr><th id="3">3</th><td><i>/***************************************************************************</i></td></tr>
<tr><th id="4">4</th><td><i> *                                  _   _ ____  _     </i></td></tr>
<tr><th id="5">5</th><td><i> *  Project                     ___| | | |  _ \| |    </i></td></tr>
<tr><th id="6">6</th><td><i> *                             / __| | | | |_) | |    </i></td></tr>
<tr><th id="7">7</th><td><i> *                            | (__| |_| |  _ &lt;| |___ </i></td></tr>
<tr><th id="8">8</th><td><i> *                             \___|\___/|_| \_\_____|</i></td></tr>
<tr><th id="9">9</th><td><i> *</i></td></tr>
<tr><th id="10">10</th><td><i> * Copyright (C) 1998 - 2004, Daniel Stenberg, &lt;daniel@haxx.se&gt;, et al.</i></td></tr>
<tr><th id="11">11</th><td><i> *</i></td></tr>
<tr><th id="12">12</th><td><i> * This software is licensed as described in the file COPYING, which</i></td></tr>
<tr><th id="13">13</th><td><i> * you should have received as part of this distribution. The terms</i></td></tr>
<tr><th id="14">14</th><td><i> * are also available at <a href="http://curl.haxx.se/docs/copyright.html">http://curl.haxx.se/docs/copyright.html</a>.</i></td></tr>
<tr><th id="15">15</th><td><i> * </i></td></tr>
<tr><th id="16">16</th><td><i> * You may opt to use, copy, modify, merge, publish, distribute and/or sell</i></td></tr>
<tr><th id="17">17</th><td><i> * copies of the Software, and permit persons to whom the Software is</i></td></tr>
<tr><th id="18">18</th><td><i> * furnished to do so, under the terms of the COPYING file.</i></td></tr>
<tr><th id="19">19</th><td><i> *</i></td></tr>
<tr><th id="20">20</th><td><i> * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY</i></td></tr>
<tr><th id="21">21</th><td><i> * KIND, either express or implied.</i></td></tr>
<tr><th id="22">22</th><td><i> *</i></td></tr>
<tr><th id="23">23</th><td><i> * $Id: urldata.h,v 1.204 2004/03/12 13:06:01 bagder Exp $</i></td></tr>
<tr><th id="24">24</th><td><i> ***************************************************************************/</i></td></tr>
<tr><th id="25">25</th><td></td></tr>
<tr><th id="26">26</th><td><i>/* This file is for lib internal stuff */</i></td></tr>
<tr><th id="27">27</th><td></td></tr>
<tr><th id="28">28</th><td><u>#include <a href="setup.h.html">"setup.h"</a></u></td></tr>
<tr><th id="29">29</th><td></td></tr>
<tr><th id="30">30</th><td><u>#define <dfn class="macro" id="_M/PORT_FTP" data-ref="_M/PORT_FTP">PORT_FTP</dfn> 21</u></td></tr>
<tr><th id="31">31</th><td><u>#define <dfn class="macro" id="_M/PORT_FTPS" data-ref="_M/PORT_FTPS">PORT_FTPS</dfn> 990</u></td></tr>
<tr><th id="32">32</th><td><u>#define <dfn class="macro" id="_M/PORT_TELNET" data-ref="_M/PORT_TELNET">PORT_TELNET</dfn> 23</u></td></tr>
<tr><th id="33">33</th><td><u>#define <dfn class="macro" id="_M/PORT_GOPHER" data-ref="_M/PORT_GOPHER">PORT_GOPHER</dfn> 70</u></td></tr>
<tr><th id="34">34</th><td><u>#define <dfn class="macro" id="_M/PORT_HTTP" data-ref="_M/PORT_HTTP">PORT_HTTP</dfn> 80</u></td></tr>
<tr><th id="35">35</th><td><u>#define <dfn class="macro" id="_M/PORT_HTTPS" data-ref="_M/PORT_HTTPS">PORT_HTTPS</dfn> 443</u></td></tr>
<tr><th id="36">36</th><td><u>#define <dfn class="macro" id="_M/PORT_DICT" data-ref="_M/PORT_DICT">PORT_DICT</dfn> 2628</u></td></tr>
<tr><th id="37">37</th><td><u>#define <dfn class="macro" id="_M/PORT_LDAP" data-ref="_M/PORT_LDAP">PORT_LDAP</dfn> 389</u></td></tr>
<tr><th id="38">38</th><td></td></tr>
<tr><th id="39">39</th><td><u>#define <dfn class="macro" id="_M/DICT_MATCH" data-ref="_M/DICT_MATCH">DICT_MATCH</dfn> "/MATCH:"</u></td></tr>
<tr><th id="40">40</th><td><u>#define <dfn class="macro" id="_M/DICT_MATCH2" data-ref="_M/DICT_MATCH2">DICT_MATCH2</dfn> "/M:"</u></td></tr>
<tr><th id="41">41</th><td><u>#define <dfn class="macro" id="_M/DICT_MATCH3" data-ref="_M/DICT_MATCH3">DICT_MATCH3</dfn> "/FIND:"</u></td></tr>
<tr><th id="42">42</th><td><u>#define <dfn class="macro" id="_M/DICT_DEFINE" data-ref="_M/DICT_DEFINE">DICT_DEFINE</dfn> "/DEFINE:"</u></td></tr>
<tr><th id="43">43</th><td><u>#define <dfn class="macro" id="_M/DICT_DEFINE2" data-ref="_M/DICT_DEFINE2">DICT_DEFINE2</dfn> "/D:"</u></td></tr>
<tr><th id="44">44</th><td><u>#define <dfn class="macro" id="_M/DICT_DEFINE3" data-ref="_M/DICT_DEFINE3">DICT_DEFINE3</dfn> "/LOOKUP:"</u></td></tr>
<tr><th id="45">45</th><td></td></tr>
<tr><th id="46">46</th><td><u>#define <dfn class="macro" id="_M/CURL_DEFAULT_USER" data-ref="_M/CURL_DEFAULT_USER">CURL_DEFAULT_USER</dfn> "anonymous"</u></td></tr>
<tr><th id="47">47</th><td><u>#define <dfn class="macro" id="_M/CURL_DEFAULT_PASSWORD" data-ref="_M/CURL_DEFAULT_PASSWORD">CURL_DEFAULT_PASSWORD</dfn> "curl_by_daniel@haxx.se"</u></td></tr>
<tr><th id="48">48</th><td></td></tr>
<tr><th id="49">49</th><td><u>#include <a href="cookie.h.html">"cookie.h"</a></u></td></tr>
<tr><th id="50">50</th><td><u>#include <a href="formdata.h.html">"formdata.h"</a></u></td></tr>
<tr><th id="51">51</th><td>    </td></tr>
<tr><th id="52">52</th><td><u>#<span data-ppcond="52">ifdef</span> <span class="macro" data-ref="_M/USE_SSLEAY">USE_SSLEAY</span></u></td></tr>
<tr><th id="53">53</th><td><i>/* SSLeay stuff usually in /usr/local/ssl/include */</i></td></tr>
<tr><th id="54">54</th><td><u>#ifdef USE_OPENSSL</u></td></tr>
<tr><th id="55">55</th><td><u>#include "openssl/rsa.h"</u></td></tr>
<tr><th id="56">56</th><td><u>#include "openssl/crypto.h"</u></td></tr>
<tr><th id="57">57</th><td><u>#include "openssl/x509.h"</u></td></tr>
<tr><th id="58">58</th><td><u>#include "openssl/pem.h"</u></td></tr>
<tr><th id="59">59</th><td><u>#include "openssl/ssl.h"</u></td></tr>
<tr><th id="60">60</th><td><u>#include "openssl/err.h"</u></td></tr>
<tr><th id="61">61</th><td><u>#ifdef HAVE_OPENSSL_ENGINE_H</u></td></tr>
<tr><th id="62">62</th><td><u>#include &lt;openssl/engine.h&gt;</u></td></tr>
<tr><th id="63">63</th><td><u>#endif</u></td></tr>
<tr><th id="64">64</th><td><u>#else</u></td></tr>
<tr><th id="65">65</th><td><u>#include "rsa.h"</u></td></tr>
<tr><th id="66">66</th><td><u>#include "crypto.h"</u></td></tr>
<tr><th id="67">67</th><td><u>#include "x509.h"</u></td></tr>
<tr><th id="68">68</th><td><u>#include "pem.h"</u></td></tr>
<tr><th id="69">69</th><td><u>#include "ssl.h"</u></td></tr>
<tr><th id="70">70</th><td><u>#include "err.h"</u></td></tr>
<tr><th id="71">71</th><td><u>#endif</u></td></tr>
<tr><th id="72">72</th><td><u>#<span data-ppcond="52">endif</span></u></td></tr>
<tr><th id="73">73</th><td></td></tr>
<tr><th id="74">74</th><td><u>#<span data-ppcond="74">ifdef</span> <a class="macro" href="config.h.html#206" data-ref="_M/HAVE_NETINET_IN_H">HAVE_NETINET_IN_H</a></u></td></tr>
<tr><th id="75">75</th><td><u>#include <a href="../../../include/netinet/in.h.html">&lt;netinet/in.h&gt;</a></u></td></tr>
<tr><th id="76">76</th><td><u>#<span data-ppcond="74">endif</span></u></td></tr>
<tr><th id="77">77</th><td></td></tr>
<tr><th id="78">78</th><td><u>#include <a href="timeval.h.html">"timeval.h"</a></u></td></tr>
<tr><th id="79">79</th><td></td></tr>
<tr><th id="80">80</th><td><u>#<span data-ppcond="80">ifdef</span> <a class="macro" href="config.h.html#401" data-ref="_M/HAVE_ZLIB_H">HAVE_ZLIB_H</a></u></td></tr>
<tr><th id="81">81</th><td><u>#include <a href="../../../include/zlib.h.html">&lt;zlib.h&gt;</a> 		/* for content-encoding */</u></td></tr>
<tr><th id="82">82</th><td><u>#<span data-ppcond="80">endif</span></u></td></tr>
<tr><th id="83">83</th><td></td></tr>
<tr><th id="84">84</th><td><u>#include <a href="../include/curl/curl.h.html">&lt;curl/curl.h&gt;</a></u></td></tr>
<tr><th id="85">85</th><td></td></tr>
<tr><th id="86">86</th><td><u>#include <a href="http_chunks.h.html">"http_chunks.h"</a> /* for the structs and enum stuff */</u></td></tr>
<tr><th id="87">87</th><td><u>#include <a href="hostip.h.html">"hostip.h"</a></u></td></tr>
<tr><th id="88">88</th><td><u>#include <a href="hash.h.html">"hash.h"</a></u></td></tr>
<tr><th id="89">89</th><td></td></tr>
<tr><th id="90">90</th><td><u>#<span data-ppcond="90">ifdef</span> <span class="macro" data-ref="_M/HAVE_GSSAPI">HAVE_GSSAPI</span></u></td></tr>
<tr><th id="91">91</th><td><u>#ifdef HAVE_GSSMIT</u></td></tr>
<tr><th id="92">92</th><td><u>#include &lt;gssapi/gssapi.h&gt;</u></td></tr>
<tr><th id="93">93</th><td><u>#include &lt;gssapi/gssapi_generic.h&gt;</u></td></tr>
<tr><th id="94">94</th><td><u>#else</u></td></tr>
<tr><th id="95">95</th><td><u>#include &lt;gssapi.h&gt;</u></td></tr>
<tr><th id="96">96</th><td><u>#endif</u></td></tr>
<tr><th id="97">97</th><td><u>#<span data-ppcond="90">endif</span></u></td></tr>
<tr><th id="98">98</th><td></td></tr>
<tr><th id="99">99</th><td><u>#<span data-ppcond="99">ifdef</span> <span class="macro" data-ref="_M/USE_ARES">USE_ARES</span></u></td></tr>
<tr><th id="100">100</th><td><u>#include &lt;ares.h&gt;</u></td></tr>
<tr><th id="101">101</th><td><u>#<span data-ppcond="99">endif</span></u></td></tr>
<tr><th id="102">102</th><td></td></tr>
<tr><th id="103">103</th><td><i>/* Download buffer size, keep it fairly big for speed reasons */</i></td></tr>
<tr><th id="104">104</th><td><u>#define <dfn class="macro" id="_M/BUFSIZE" data-ref="_M/BUFSIZE">BUFSIZE</dfn> CURL_MAX_WRITE_SIZE</u></td></tr>
<tr><th id="105">105</th><td></td></tr>
<tr><th id="106">106</th><td><i>/* Initial size of the buffer to store headers in, it'll be enlarged in case</i></td></tr>
<tr><th id="107">107</th><td><i>   of need. */</i></td></tr>
<tr><th id="108">108</th><td><u>#define <dfn class="macro" id="_M/HEADERSIZE" data-ref="_M/HEADERSIZE">HEADERSIZE</dfn> 256</u></td></tr>
<tr><th id="109">109</th><td></td></tr>
<tr><th id="110">110</th><td><i>/* Maximum number of dirs supported by libcurl in a FTP dir hierarchy */</i></td></tr>
<tr><th id="111">111</th><td><u>#define <dfn class="macro" id="_M/CURL_MAX_FTP_DIRDEPTH" data-ref="_M/CURL_MAX_FTP_DIRDEPTH">CURL_MAX_FTP_DIRDEPTH</dfn> 100</u></td></tr>
<tr><th id="112">112</th><td></td></tr>
<tr><th id="113">113</th><td><i>/* Just a convenience macro to get the larger value out of two given.</i></td></tr>
<tr><th id="114">114</th><td><i>   We prefix with CURL to prevent name collisions. */</i></td></tr>
<tr><th id="115">115</th><td><u>#define <dfn class="macro" id="_M/CURLMAX" data-ref="_M/CURLMAX">CURLMAX</dfn>(x,y) ((x)&gt;(y)?(x):(y))</u></td></tr>
<tr><th id="116">116</th><td></td></tr>
<tr><th id="117">117</th><td><u>#<span data-ppcond="117">ifdef</span> <span class="macro" data-ref="_M/HAVE_KRB4">HAVE_KRB4</span></u></td></tr>
<tr><th id="118">118</th><td><i>/* Types needed for krb4-ftp connections */</i></td></tr>
<tr><th id="119">119</th><td><b>struct</b> krb4buffer {</td></tr>
<tr><th id="120">120</th><td>  <em>void</em> *data;</td></tr>
<tr><th id="121">121</th><td>  size_t size;</td></tr>
<tr><th id="122">122</th><td>  size_t index;</td></tr>
<tr><th id="123">123</th><td>  <em>int</em> eof_flag;</td></tr>
<tr><th id="124">124</th><td>};</td></tr>
<tr><th id="125">125</th><td><b>enum</b> protection_level { </td></tr>
<tr><th id="126">126</th><td>    prot_clear, </td></tr>
<tr><th id="127">127</th><td>    prot_safe, </td></tr>
<tr><th id="128">128</th><td>    prot_confidential, </td></tr>
<tr><th id="129">129</th><td>    prot_private </td></tr>
<tr><th id="130">130</th><td>};</td></tr>
<tr><th id="131">131</th><td><u>#<span data-ppcond="117">endif</span></u></td></tr>
<tr><th id="132">132</th><td></td></tr>
<tr><th id="133">133</th><td><i>/* struct for data related to each SSL connection */</i></td></tr>
<tr><th id="134">134</th><td><b>struct</b> <dfn class="type def" id="ssl_connect_data" title='ssl_connect_data' data-ref="ssl_connect_data">ssl_connect_data</dfn> {</td></tr>
<tr><th id="135">135</th><td>  <a class="typedef" href="setup.h.html#bool" title='bool' data-type='unsigned char' data-ref="bool">bool</a> <dfn class="decl" id="ssl_connect_data::use" title='ssl_connect_data::use' data-ref="ssl_connect_data::use">use</dfn>;        <i>/* use ssl encrypted communications TRUE/FALSE */</i></td></tr>
<tr><th id="136">136</th><td><u>#<span data-ppcond="136">ifdef</span> <span class="macro" data-ref="_M/USE_SSLEAY">USE_SSLEAY</span></u></td></tr>
<tr><th id="137">137</th><td>  <i>/* these ones requires specific SSL-types */</i></td></tr>
<tr><th id="138">138</th><td>  SSL_CTX* ctx;</td></tr>
<tr><th id="139">139</th><td>  SSL*     handle;</td></tr>
<tr><th id="140">140</th><td>  X509*    server_cert;</td></tr>
<tr><th id="141">141</th><td><u>#<span data-ppcond="136">endif</span> /* USE_SSLEAY */</u></td></tr>
<tr><th id="142">142</th><td>};</td></tr>
<tr><th id="143">143</th><td></td></tr>
<tr><th id="144">144</th><td><b>struct</b> <dfn class="type def" id="ssl_config_data" title='ssl_config_data' data-ref="ssl_config_data">ssl_config_data</dfn> {</td></tr>
<tr><th id="145">145</th><td>  <em>long</em> <dfn class="decl" id="ssl_config_data::version" title='ssl_config_data::version' data-ref="ssl_config_data::version">version</dfn>;          <i>/* what version the client wants to use */</i></td></tr>
<tr><th id="146">146</th><td>  <em>long</em> <dfn class="decl" id="ssl_config_data::certverifyresult" title='ssl_config_data::certverifyresult' data-ref="ssl_config_data::certverifyresult">certverifyresult</dfn>; <i>/* result from the certificate verification */</i></td></tr>
<tr><th id="147">147</th><td>  <em>long</em> <dfn class="decl" id="ssl_config_data::verifypeer" title='ssl_config_data::verifypeer' data-ref="ssl_config_data::verifypeer">verifypeer</dfn>;       <i>/* set TRUE if this is desired */</i></td></tr>
<tr><th id="148">148</th><td>  <em>long</em> <dfn class="decl" id="ssl_config_data::verifyhost" title='ssl_config_data::verifyhost' data-ref="ssl_config_data::verifyhost">verifyhost</dfn>;       <i>/* 0: no verify</i></td></tr>
<tr><th id="149">149</th><td><i>                            1: check that CN exists</i></td></tr>
<tr><th id="150">150</th><td><i>                            2: CN must match hostname */</i></td></tr>
<tr><th id="151">151</th><td>  <em>char</em> *<dfn class="decl" id="ssl_config_data::CApath" title='ssl_config_data::CApath' data-ref="ssl_config_data::CApath">CApath</dfn>;          <i>/* DOES NOT WORK ON WINDOWS */</i></td></tr>
<tr><th id="152">152</th><td>  <em>char</em> *<dfn class="decl" id="ssl_config_data::CAfile" title='ssl_config_data::CAfile' data-ref="ssl_config_data::CAfile">CAfile</dfn>;          <i>/* cerficate to verify peer against */</i></td></tr>
<tr><th id="153">153</th><td>  <em>char</em> *<dfn class="decl" id="ssl_config_data::random_file" title='ssl_config_data::random_file' data-ref="ssl_config_data::random_file">random_file</dfn>;     <i>/* path to file containing "random" data */</i></td></tr>
<tr><th id="154">154</th><td>  <em>char</em> *<dfn class="decl" id="ssl_config_data::egdsocket" title='ssl_config_data::egdsocket' data-ref="ssl_config_data::egdsocket">egdsocket</dfn>;       <i>/* path to file containing the EGD daemon socket */</i></td></tr>
<tr><th id="155">155</th><td>  <em>char</em> *<dfn class="decl" id="ssl_config_data::cipher_list" title='ssl_config_data::cipher_list' data-ref="ssl_config_data::cipher_list">cipher_list</dfn>;     <i>/* list of ciphers to use */</i></td></tr>
<tr><th id="156">156</th><td>  <em>long</em> <dfn class="decl" id="ssl_config_data::numsessions" title='ssl_config_data::numsessions' data-ref="ssl_config_data::numsessions">numsessions</dfn>;      <i>/* SSL session id cache size */</i></td></tr>
<tr><th id="157">157</th><td>  <a class="typedef" href="../include/curl/curl.h.html#curl_ssl_ctx_callback" title='curl_ssl_ctx_callback' data-type='CURLcode (*)(CURL *, void *, void *)' data-ref="curl_ssl_ctx_callback">curl_ssl_ctx_callback</a> <dfn class="decl" id="ssl_config_data::fsslctx" title='ssl_config_data::fsslctx' data-ref="ssl_config_data::fsslctx">fsslctx</dfn>; 	<i>/* function to initialize ssl ctx */</i></td></tr>
<tr><th id="158">158</th><td>  <em>void</em> *<dfn class="decl" id="ssl_config_data::fsslctxp" title='ssl_config_data::fsslctxp' data-ref="ssl_config_data::fsslctxp">fsslctxp</dfn>; 	<i>/*parameter for call back */</i></td></tr>
<tr><th id="159">159</th><td>};</td></tr>
<tr><th id="160">160</th><td></td></tr>
<tr><th id="161">161</th><td><i>/* information stored about one single SSL session */</i></td></tr>
<tr><th id="162">162</th><td><b>struct</b> <dfn class="type def" id="curl_ssl_session" title='curl_ssl_session' data-ref="curl_ssl_session">curl_ssl_session</dfn> {</td></tr>
<tr><th id="163">163</th><td>  <em>char</em> *<dfn class="decl" id="curl_ssl_session::name" title='curl_ssl_session::name' data-ref="curl_ssl_session::name">name</dfn>;       <i>/* host name for which this ID was used */</i></td></tr>
<tr><th id="164">164</th><td>  <em>void</em> *<dfn class="decl" id="curl_ssl_session::sessionid" title='curl_ssl_session::sessionid' data-ref="curl_ssl_session::sessionid">sessionid</dfn>;  <i>/* as returned from the SSL layer */</i></td></tr>
<tr><th id="165">165</th><td>  <em>long</em> <dfn class="decl" id="curl_ssl_session::age" title='curl_ssl_session::age' data-ref="curl_ssl_session::age">age</dfn>;         <i>/* just a number, the higher the more recent */</i></td></tr>
<tr><th id="166">166</th><td>  <em>unsigned</em> <em>short</em> <dfn class="decl" id="curl_ssl_session::remote_port" title='curl_ssl_session::remote_port' data-ref="curl_ssl_session::remote_port">remote_port</dfn>; <i>/* remote port to connect to */</i></td></tr>
<tr><th id="167">167</th><td>  <b>struct</b> <a class="type" href="#ssl_config_data" title='ssl_config_data' data-ref="ssl_config_data">ssl_config_data</a> <dfn class="decl" id="curl_ssl_session::ssl_config" title='curl_ssl_session::ssl_config' data-ref="curl_ssl_session::ssl_config">ssl_config</dfn>; <i>/* setup for this session */</i></td></tr>
<tr><th id="168">168</th><td>};</td></tr>
<tr><th id="169">169</th><td></td></tr>
<tr><th id="170">170</th><td><i>/* Struct used for Digest challenge-response authentication */</i></td></tr>
<tr><th id="171">171</th><td><b>struct</b> <dfn class="type def" id="digestdata" title='digestdata' data-ref="digestdata">digestdata</dfn> {</td></tr>
<tr><th id="172">172</th><td>  <em>char</em> *<dfn class="decl" id="digestdata::nonce" title='digestdata::nonce' data-ref="digestdata::nonce">nonce</dfn>;</td></tr>
<tr><th id="173">173</th><td>  <em>char</em> *<dfn class="decl" id="digestdata::cnonce" title='digestdata::cnonce' data-ref="digestdata::cnonce">cnonce</dfn>;</td></tr>
<tr><th id="174">174</th><td>  <em>char</em> *<dfn class="decl" id="digestdata::realm" title='digestdata::realm' data-ref="digestdata::realm">realm</dfn>;</td></tr>
<tr><th id="175">175</th><td>  <em>int</em> <dfn class="decl" id="digestdata::algo" title='digestdata::algo' data-ref="digestdata::algo">algo</dfn>;</td></tr>
<tr><th id="176">176</th><td>};</td></tr>
<tr><th id="177">177</th><td></td></tr>
<tr><th id="178">178</th><td><b>typedef</b> <b>enum</b> {</td></tr>
<tr><th id="179">179</th><td>  <dfn class="enum" id="NTLMSTATE_NONE" title='NTLMSTATE_NONE' data-ref="NTLMSTATE_NONE">NTLMSTATE_NONE</dfn>,</td></tr>
<tr><th id="180">180</th><td>  <dfn class="enum" id="NTLMSTATE_TYPE1" title='NTLMSTATE_TYPE1' data-ref="NTLMSTATE_TYPE1">NTLMSTATE_TYPE1</dfn>,</td></tr>
<tr><th id="181">181</th><td>  <dfn class="enum" id="NTLMSTATE_TYPE2" title='NTLMSTATE_TYPE2' data-ref="NTLMSTATE_TYPE2">NTLMSTATE_TYPE2</dfn>,</td></tr>
<tr><th id="182">182</th><td>  <dfn class="enum" id="NTLMSTATE_TYPE3" title='NTLMSTATE_TYPE3' data-ref="NTLMSTATE_TYPE3">NTLMSTATE_TYPE3</dfn>,</td></tr>
<tr><th id="183">183</th><td>  <dfn class="enum" id="NTLMSTATE_LAST" title='NTLMSTATE_LAST' data-ref="NTLMSTATE_LAST">NTLMSTATE_LAST</dfn></td></tr>
<tr><th id="184">184</th><td>} <dfn class="typedef" id="curlntlm" title='curlntlm' data-type='enum curlntlm' data-ref="curlntlm">curlntlm</dfn>;</td></tr>
<tr><th id="185">185</th><td></td></tr>
<tr><th id="186">186</th><td><i>/* Struct used for NTLM challenge-response authentication */</i></td></tr>
<tr><th id="187">187</th><td><b>struct</b> <dfn class="type def" id="ntlmdata" title='ntlmdata' data-ref="ntlmdata">ntlmdata</dfn> {</td></tr>
<tr><th id="188">188</th><td>  <a class="typedef" href="#curlntlm" title='curlntlm' data-type='enum curlntlm' data-ref="curlntlm">curlntlm</a> <dfn class="decl" id="ntlmdata::state" title='ntlmdata::state' data-ref="ntlmdata::state">state</dfn>;</td></tr>
<tr><th id="189">189</th><td>  <em>unsigned</em> <em>char</em> <dfn class="decl" id="ntlmdata::nonce" title='ntlmdata::nonce' data-ref="ntlmdata::nonce">nonce</dfn>[<var>8</var>];</td></tr>
<tr><th id="190">190</th><td>};</td></tr>
<tr><th id="191">191</th><td></td></tr>
<tr><th id="192">192</th><td><u>#<span data-ppcond="192">ifdef</span> <span class="macro" data-ref="_M/HAVE_GSSAPI">HAVE_GSSAPI</span></u></td></tr>
<tr><th id="193">193</th><td><b>struct</b> negotiatedata {</td></tr>
<tr><th id="194">194</th><td>  bool gss; <i>/* Whether we're processing GSS-Negotiate or Negotiate */</i></td></tr>
<tr><th id="195">195</th><td>  <em>const</em> <em>char</em>* protocol; <i>/* "GSS-Negotiate" or "Negotiate" */</i></td></tr>
<tr><th id="196">196</th><td>  OM_uint32 status;</td></tr>
<tr><th id="197">197</th><td>  gss_ctx_id_t context;</td></tr>
<tr><th id="198">198</th><td>  gss_name_t server_name;</td></tr>
<tr><th id="199">199</th><td>  gss_buffer_desc output_token;</td></tr>
<tr><th id="200">200</th><td>};</td></tr>
<tr><th id="201">201</th><td><u>#<span data-ppcond="192">endif</span></u></td></tr>
<tr><th id="202">202</th><td></td></tr>
<tr><th id="203">203</th><td><i>/****************************************************************************</i></td></tr>
<tr><th id="204">204</th><td><i> * HTTP unique setup</i></td></tr>
<tr><th id="205">205</th><td><i> ***************************************************************************/</i></td></tr>
<tr><th id="206">206</th><td><b>struct</b> <dfn class="type def" id="HTTP" title='HTTP' data-ref="HTTP">HTTP</dfn> {</td></tr>
<tr><th id="207">207</th><td>  <b>struct</b> <a class="type" href="formdata.h.html#FormData" title='FormData' data-ref="FormData">FormData</a> *<dfn class="decl" id="HTTP::sendit" title='HTTP::sendit' data-ref="HTTP::sendit">sendit</dfn>;</td></tr>
<tr><th id="208">208</th><td>  <a class="typedef" href="../include/curl/curl.h.html#curl_off_t" title='curl_off_t' data-type='off_t' data-ref="curl_off_t">curl_off_t</a> <dfn class="decl" id="HTTP::postsize" title='HTTP::postsize' data-ref="HTTP::postsize">postsize</dfn>; <i>/* off_t to handle large file sizes */</i></td></tr>
<tr><th id="209">209</th><td>  <em>char</em> *<dfn class="decl" id="HTTP::postdata" title='HTTP::postdata' data-ref="HTTP::postdata">postdata</dfn>;</td></tr>
<tr><th id="210">210</th><td></td></tr>
<tr><th id="211">211</th><td>  <em>const</em> <em>char</em> *<dfn class="decl" id="HTTP::p_pragma" title='HTTP::p_pragma' data-ref="HTTP::p_pragma">p_pragma</dfn>;      <i>/* Pragma: string */</i></td></tr>
<tr><th id="212">212</th><td>  <em>const</em> <em>char</em> *<dfn class="decl" id="HTTP::p_accept" title='HTTP::p_accept' data-ref="HTTP::p_accept">p_accept</dfn>;      <i>/* Accept: string */</i></td></tr>
<tr><th id="213">213</th><td>  <a class="typedef" href="../include/curl/curl.h.html#curl_off_t" title='curl_off_t' data-type='off_t' data-ref="curl_off_t">curl_off_t</a> <dfn class="decl" id="HTTP::readbytecount" title='HTTP::readbytecount' data-ref="HTTP::readbytecount">readbytecount</dfn>; </td></tr>
<tr><th id="214">214</th><td>  <a class="typedef" href="../include/curl/curl.h.html#curl_off_t" title='curl_off_t' data-type='off_t' data-ref="curl_off_t">curl_off_t</a> <dfn class="decl" id="HTTP::writebytecount" title='HTTP::writebytecount' data-ref="HTTP::writebytecount">writebytecount</dfn>;</td></tr>
<tr><th id="215">215</th><td></td></tr>
<tr><th id="216">216</th><td>  <i>/* For FORM posting */</i></td></tr>
<tr><th id="217">217</th><td>  <b>struct</b> <a class="type" href="formdata.h.html#Form" title='Form' data-ref="Form">Form</a> <dfn class="decl" id="HTTP::form" title='HTTP::form' data-ref="HTTP::form">form</dfn>;</td></tr>
<tr><th id="218">218</th><td>  <b>struct</b> <a class="type" href="http_chunks.h.html#Curl_chunker" title='Curl_chunker' data-ref="Curl_chunker">Curl_chunker</a> <dfn class="decl" id="HTTP::chunk" title='HTTP::chunk' data-ref="HTTP::chunk">chunk</dfn>;</td></tr>
<tr><th id="219">219</th><td></td></tr>
<tr><th id="220">220</th><td>  <b>struct</b> <dfn class="type def" id="back" title='back' data-ref="back"><a class="type" href="#back" title='back' data-ref="back">back</a></dfn> {</td></tr>
<tr><th id="221">221</th><td>    <a class="typedef" href="../include/curl/curl.h.html#curl_read_callback" title='curl_read_callback' data-type='size_t (*)(char *, size_t, size_t, void *)' data-ref="curl_read_callback">curl_read_callback</a> <dfn class="decl" id="back::fread" title='back::fread' data-ref="back::fread">fread</dfn>; <i>/* backup storage for fread pointer */</i></td></tr>
<tr><th id="222">222</th><td>    <em>void</em> *<dfn class="decl" id="back::fread_in" title='back::fread_in' data-ref="back::fread_in">fread_in</dfn>;           <i>/* backup storage for fread_in pointer */</i></td></tr>
<tr><th id="223">223</th><td>    <em>char</em> *<dfn class="decl" id="back::postdata" title='back::postdata' data-ref="back::postdata">postdata</dfn>;</td></tr>
<tr><th id="224">224</th><td>    <a class="typedef" href="../include/curl/curl.h.html#curl_off_t" title='curl_off_t' data-type='off_t' data-ref="curl_off_t">curl_off_t</a> <dfn class="decl" id="back::postsize" title='back::postsize' data-ref="back::postsize">postsize</dfn>;</td></tr>
<tr><th id="225">225</th><td>  } <dfn class="decl" id="HTTP::backup" title='HTTP::backup' data-ref="HTTP::backup">backup</dfn>;</td></tr>
<tr><th id="226">226</th><td></td></tr>
<tr><th id="227">227</th><td>  <b>enum</b> {</td></tr>
<tr><th id="228">228</th><td>    <dfn class="enum" id="HTTP::HTTPSEND_NADA" title='HTTP::HTTPSEND_NADA' data-ref="HTTP::HTTPSEND_NADA">HTTPSEND_NADA</dfn>,    <i>/* init */</i></td></tr>
<tr><th id="229">229</th><td>    <dfn class="enum" id="HTTP::HTTPSEND_REQUEST" title='HTTP::HTTPSEND_REQUEST' data-ref="HTTP::HTTPSEND_REQUEST">HTTPSEND_REQUEST</dfn>, <i>/* sending a request */</i></td></tr>
<tr><th id="230">230</th><td>    <dfn class="enum" id="HTTP::HTTPSEND_BODY" title='HTTP::HTTPSEND_BODY' data-ref="HTTP::HTTPSEND_BODY">HTTPSEND_BODY</dfn>,    <i>/* sending body */</i></td></tr>
<tr><th id="231">231</th><td>    <dfn class="enum" id="HTTP::HTTPSEND_LAST" title='HTTP::HTTPSEND_LAST' data-ref="HTTP::HTTPSEND_LAST">HTTPSEND_LAST</dfn>     <i>/* never use this */</i></td></tr>
<tr><th id="232">232</th><td>  } <dfn class="decl" id="HTTP::sending" title='HTTP::sending' data-ref="HTTP::sending">sending</dfn>;</td></tr>
<tr><th id="233">233</th><td></td></tr>
<tr><th id="234">234</th><td>  <em>void</em> *<dfn class="decl" id="HTTP::send_buffer" title='HTTP::send_buffer' data-ref="HTTP::send_buffer">send_buffer</dfn>; <i>/* used if the request couldn't be sent in one chunk,</i></td></tr>
<tr><th id="235">235</th><td><i>                        points to an allocated send_buffer struct */</i></td></tr>
<tr><th id="236">236</th><td>};</td></tr>
<tr><th id="237">237</th><td></td></tr>
<tr><th id="238">238</th><td><i>/****************************************************************************</i></td></tr>
<tr><th id="239">239</th><td><i> * FTP unique setup</i></td></tr>
<tr><th id="240">240</th><td><i> ***************************************************************************/</i></td></tr>
<tr><th id="241">241</th><td><b>struct</b> <dfn class="type def" id="FTP" title='FTP' data-ref="FTP">FTP</dfn> {</td></tr>
<tr><th id="242">242</th><td>  <a class="typedef" href="../include/curl/curl.h.html#curl_off_t" title='curl_off_t' data-type='off_t' data-ref="curl_off_t">curl_off_t</a> *<dfn class="decl" id="FTP::bytecountp" title='FTP::bytecountp' data-ref="FTP::bytecountp">bytecountp</dfn>;</td></tr>
<tr><th id="243">243</th><td>  <em>char</em> *<dfn class="decl" id="FTP::user" title='FTP::user' data-ref="FTP::user">user</dfn>;    <i>/* user name string */</i></td></tr>
<tr><th id="244">244</th><td>  <em>char</em> *<dfn class="decl" id="FTP::passwd" title='FTP::passwd' data-ref="FTP::passwd">passwd</dfn>;  <i>/* password string */</i></td></tr>
<tr><th id="245">245</th><td>  <em>char</em> *<dfn class="decl" id="FTP::urlpath" title='FTP::urlpath' data-ref="FTP::urlpath">urlpath</dfn>; <i>/* the originally given path part of the URL */</i></td></tr>
<tr><th id="246">246</th><td>  <em>char</em> *<dfn class="decl" id="FTP::dirs" title='FTP::dirs' data-ref="FTP::dirs">dirs</dfn>[<a class="macro" href="#111" title="100" data-ref="_M/CURL_MAX_FTP_DIRDEPTH">CURL_MAX_FTP_DIRDEPTH</a>]; <i>/* path components */</i></td></tr>
<tr><th id="247">247</th><td>  <em>char</em> *<dfn class="decl" id="FTP::file" title='FTP::file' data-ref="FTP::file">file</dfn>;    <i>/* decoded file */</i></td></tr>
<tr><th id="248">248</th><td></td></tr>
<tr><th id="249">249</th><td>  <em>char</em> *<dfn class="decl" id="FTP::entrypath" title='FTP::entrypath' data-ref="FTP::entrypath">entrypath</dfn>; <i>/* the PWD reply when we logged on */</i></td></tr>
<tr><th id="250">250</th><td></td></tr>
<tr><th id="251">251</th><td>  <em>char</em> *<dfn class="decl" id="FTP::cache" title='FTP::cache' data-ref="FTP::cache">cache</dfn>;       <i>/* data cache between getresponse()-calls */</i></td></tr>
<tr><th id="252">252</th><td>  <a class="typedef" href="../include/curl/curl.h.html#curl_off_t" title='curl_off_t' data-type='off_t' data-ref="curl_off_t">curl_off_t</a> <dfn class="decl" id="FTP::cache_size" title='FTP::cache_size' data-ref="FTP::cache_size">cache_size</dfn>; <i>/* size of cache in bytes */</i></td></tr>
<tr><th id="253">253</th><td>  <a class="typedef" href="setup.h.html#bool" title='bool' data-type='unsigned char' data-ref="bool">bool</a> <dfn class="decl" id="FTP::dont_check" title='FTP::dont_check' data-ref="FTP::dont_check">dont_check</dfn>;  <i>/* Set to TRUE to prevent the final (post-transfer)</i></td></tr>
<tr><th id="254">254</th><td><i>                       file size and 226/250 status check. It should still</i></td></tr>
<tr><th id="255">255</th><td><i>                       read the line, just ignore the result. */</i></td></tr>
<tr><th id="256">256</th><td>  <a class="typedef" href="setup.h.html#bool" title='bool' data-type='unsigned char' data-ref="bool">bool</a> <dfn class="decl" id="FTP::no_transfer" title='FTP::no_transfer' data-ref="FTP::no_transfer">no_transfer</dfn>; <i>/* nothing was transfered, (possibly because a resumed</i></td></tr>
<tr><th id="257">257</th><td><i>                       transfer already was complete) */</i></td></tr>
<tr><th id="258">258</th><td>  <em>long</em> <dfn class="decl" id="FTP::response_time" title='FTP::response_time' data-ref="FTP::response_time">response_time</dfn>; <i>/* When no timeout is given, this is the amount of</i></td></tr>
<tr><th id="259">259</th><td><i>                         seconds we await for an FTP response. Initialized</i></td></tr>
<tr><th id="260">260</th><td><i>                         in Curl_ftp_connect() */</i></td></tr>
<tr><th id="261">261</th><td>  <a class="typedef" href="setup.h.html#bool" title='bool' data-type='unsigned char' data-ref="bool">bool</a> <dfn class="decl" id="FTP::ctl_valid" title='FTP::ctl_valid' data-ref="FTP::ctl_valid">ctl_valid</dfn>;     <i>/* Tells Curl_ftp_quit() whether or not to do </i></td></tr>
<tr><th id="262">262</th><td><i>                         anything. If the connection has timed out or</i></td></tr>
<tr><th id="263">263</th><td><i>                         been closed, this should be FALSE when it gets</i></td></tr>
<tr><th id="264">264</th><td><i>                         to Curl_ftp_quit() */</i></td></tr>
<tr><th id="265">265</th><td>};</td></tr>
<tr><th id="266">266</th><td></td></tr>
<tr><th id="267">267</th><td><i>/****************************************************************************</i></td></tr>
<tr><th id="268">268</th><td><i> * FILE unique setup</i></td></tr>
<tr><th id="269">269</th><td><i> ***************************************************************************/</i></td></tr>
<tr><th id="270">270</th><td><b>struct</b> <dfn class="type def" id="FILEPROTO" title='FILEPROTO' data-ref="FILEPROTO">FILEPROTO</dfn> {</td></tr>
<tr><th id="271">271</th><td>  <em>int</em> <dfn class="decl" id="FILEPROTO::fd" title='FILEPROTO::fd' data-ref="FILEPROTO::fd">fd</dfn>; <i>/* open file descriptor to read from! */</i></td></tr>
<tr><th id="272">272</th><td>};</td></tr>
<tr><th id="273">273</th><td></td></tr>
<tr><th id="274">274</th><td><i>/*</i></td></tr>
<tr><th id="275">275</th><td><i> * Boolean values that concerns this connection.</i></td></tr>
<tr><th id="276">276</th><td><i> */</i></td></tr>
<tr><th id="277">277</th><td><b>struct</b> <dfn class="type def" id="ConnectBits" title='ConnectBits' data-ref="ConnectBits">ConnectBits</dfn> {</td></tr>
<tr><th id="278">278</th><td>  <a class="typedef" href="setup.h.html#bool" title='bool' data-type='unsigned char' data-ref="bool">bool</a> <dfn class="decl" id="ConnectBits::close" title='ConnectBits::close' data-ref="ConnectBits::close">close</dfn>; <i>/* if set, we close the connection after this request */</i></td></tr>
<tr><th id="279">279</th><td>  <a class="typedef" href="setup.h.html#bool" title='bool' data-type='unsigned char' data-ref="bool">bool</a> <dfn class="decl" id="ConnectBits::reuse" title='ConnectBits::reuse' data-ref="ConnectBits::reuse">reuse</dfn>; <i>/* if set, this is a re-used connection */</i></td></tr>
<tr><th id="280">280</th><td>  <a class="typedef" href="setup.h.html#bool" title='bool' data-type='unsigned char' data-ref="bool">bool</a> <dfn class="decl" id="ConnectBits::chunk" title='ConnectBits::chunk' data-ref="ConnectBits::chunk">chunk</dfn>; <i>/* if set, this is a chunked transfer-encoding */</i></td></tr>
<tr><th id="281">281</th><td>  <a class="typedef" href="setup.h.html#bool" title='bool' data-type='unsigned char' data-ref="bool">bool</a> <dfn class="decl" id="ConnectBits::httpproxy" title='ConnectBits::httpproxy' data-ref="ConnectBits::httpproxy">httpproxy</dfn>;    <i>/* if set, this transfer is done through a http proxy */</i></td></tr>
<tr><th id="282">282</th><td>  <a class="typedef" href="setup.h.html#bool" title='bool' data-type='unsigned char' data-ref="bool">bool</a> <dfn class="decl" id="ConnectBits::user_passwd" title='ConnectBits::user_passwd' data-ref="ConnectBits::user_passwd">user_passwd</dfn>;    <i>/* do we use user+password for this connection? */</i></td></tr>
<tr><th id="283">283</th><td>  <a class="typedef" href="setup.h.html#bool" title='bool' data-type='unsigned char' data-ref="bool">bool</a> <dfn class="decl" id="ConnectBits::proxy_user_passwd" title='ConnectBits::proxy_user_passwd' data-ref="ConnectBits::proxy_user_passwd">proxy_user_passwd</dfn>; <i>/* user+password for the proxy? */</i></td></tr>
<tr><th id="284">284</th><td>  <a class="typedef" href="setup.h.html#bool" title='bool' data-type='unsigned char' data-ref="bool">bool</a> <dfn class="decl" id="ConnectBits::ipv6_ip" title='ConnectBits::ipv6_ip' data-ref="ConnectBits::ipv6_ip">ipv6_ip</dfn>; <i>/* we communicate with a remove site specified with pure IPv6</i></td></tr>
<tr><th id="285">285</th><td><i>                   IP address */</i></td></tr>
<tr><th id="286">286</th><td>  <a class="typedef" href="setup.h.html#bool" title='bool' data-type='unsigned char' data-ref="bool">bool</a> <dfn class="decl" id="ConnectBits::use_range" title='ConnectBits::use_range' data-ref="ConnectBits::use_range">use_range</dfn>;</td></tr>
<tr><th id="287">287</th><td>  <a class="typedef" href="setup.h.html#bool" title='bool' data-type='unsigned char' data-ref="bool">bool</a> <dfn class="decl" id="ConnectBits::rangestringalloc" title='ConnectBits::rangestringalloc' data-ref="ConnectBits::rangestringalloc">rangestringalloc</dfn>; <i>/* the range string is malloc()'ed */</i></td></tr>
<tr><th id="288">288</th><td></td></tr>
<tr><th id="289">289</th><td>  <a class="typedef" href="setup.h.html#bool" title='bool' data-type='unsigned char' data-ref="bool">bool</a> <dfn class="decl" id="ConnectBits::do_more" title='ConnectBits::do_more' data-ref="ConnectBits::do_more">do_more</dfn>; <i>/* this is set TRUE if the -&gt;curl_do_more() function is</i></td></tr>
<tr><th id="290">290</th><td><i>                   supposed to be called, after -&gt;curl_do() */</i></td></tr>
<tr><th id="291">291</th><td></td></tr>
<tr><th id="292">292</th><td>  <a class="typedef" href="setup.h.html#bool" title='bool' data-type='unsigned char' data-ref="bool">bool</a> <dfn class="decl" id="ConnectBits::upload_chunky" title='ConnectBits::upload_chunky' data-ref="ConnectBits::upload_chunky">upload_chunky</dfn>; <i>/* set TRUE if we are doing chunked transfer-encoding</i></td></tr>
<tr><th id="293">293</th><td><i>                         on upload */</i></td></tr>
<tr><th id="294">294</th><td>  <a class="typedef" href="setup.h.html#bool" title='bool' data-type='unsigned char' data-ref="bool">bool</a> <dfn class="decl" id="ConnectBits::getheader" title='ConnectBits::getheader' data-ref="ConnectBits::getheader">getheader</dfn>;     <i>/* TRUE if header parsing is wanted */</i></td></tr>
<tr><th id="295">295</th><td></td></tr>
<tr><th id="296">296</th><td>  <a class="typedef" href="setup.h.html#bool" title='bool' data-type='unsigned char' data-ref="bool">bool</a> <dfn class="decl" id="ConnectBits::forbidchunk" title='ConnectBits::forbidchunk' data-ref="ConnectBits::forbidchunk">forbidchunk</dfn>;   <i>/* used only to explicitly forbid chunk-upload for</i></td></tr>
<tr><th id="297">297</th><td><i>                         specific upload buffers. See readmoredata() in</i></td></tr>
<tr><th id="298">298</th><td><i>                         http.c for details. */</i></td></tr>
<tr><th id="299">299</th><td>  <a class="typedef" href="setup.h.html#bool" title='bool' data-type='unsigned char' data-ref="bool">bool</a> <dfn class="decl" id="ConnectBits::tcpconnect" title='ConnectBits::tcpconnect' data-ref="ConnectBits::tcpconnect">tcpconnect</dfn>;    <i>/* the tcp stream (or simimlar) is connected, this</i></td></tr>
<tr><th id="300">300</th><td><i>                         is set the first time on the first connect function</i></td></tr>
<tr><th id="301">301</th><td><i>                         call */</i></td></tr>
<tr><th id="302">302</th><td>  <a class="typedef" href="setup.h.html#bool" title='bool' data-type='unsigned char' data-ref="bool">bool</a> <dfn class="decl" id="ConnectBits::retry" title='ConnectBits::retry' data-ref="ConnectBits::retry">retry</dfn>;         <i>/* this connection is about to get closed and then</i></td></tr>
<tr><th id="303">303</th><td><i>                         re-attempted at another connection. */</i></td></tr>
<tr><th id="304">304</th><td>};</td></tr>
<tr><th id="305">305</th><td></td></tr>
<tr><th id="306">306</th><td><i>/*</i></td></tr>
<tr><th id="307">307</th><td><i> * This struct is all the previously local variables from Curl_perform() moved</i></td></tr>
<tr><th id="308">308</th><td><i> * to struct to allow the function to return and get re-invoked better without</i></td></tr>
<tr><th id="309">309</th><td><i> * losing state.</i></td></tr>
<tr><th id="310">310</th><td><i> */</i></td></tr>
<tr><th id="311">311</th><td></td></tr>
<tr><th id="312">312</th><td><b>struct</b> <dfn class="type def" id="Curl_transfer_keeper" title='Curl_transfer_keeper' data-ref="Curl_transfer_keeper">Curl_transfer_keeper</dfn> {</td></tr>
<tr><th id="313">313</th><td>  <a class="typedef" href="../include/curl/curl.h.html#curl_off_t" title='curl_off_t' data-type='off_t' data-ref="curl_off_t">curl_off_t</a> <dfn class="decl" id="Curl_transfer_keeper::bytecount" title='Curl_transfer_keeper::bytecount' data-ref="Curl_transfer_keeper::bytecount">bytecount</dfn>;                <i>/* total number of bytes read */</i></td></tr>
<tr><th id="314">314</th><td>  <em>int</em> <dfn class="decl" id="Curl_transfer_keeper::writebytecount" title='Curl_transfer_keeper::writebytecount' data-ref="Curl_transfer_keeper::writebytecount">writebytecount</dfn>;           <i>/* number of bytes written */</i></td></tr>
<tr><th id="315">315</th><td>  <b>struct</b> <a class="type" href="../../../include/x86_64-linux-gnu/bits/time.h.html#timeval" title='timeval' data-ref="timeval">timeval</a> <dfn class="decl" id="Curl_transfer_keeper::start" title='Curl_transfer_keeper::start' data-ref="Curl_transfer_keeper::start">start</dfn>;         <i>/* transfer started at this time */</i></td></tr>
<tr><th id="316">316</th><td>  <b>struct</b> <a class="type" href="../../../include/x86_64-linux-gnu/bits/time.h.html#timeval" title='timeval' data-ref="timeval">timeval</a> <dfn class="decl" id="Curl_transfer_keeper::now" title='Curl_transfer_keeper::now' data-ref="Curl_transfer_keeper::now">now</dfn>;           <i>/* current time */</i></td></tr>
<tr><th id="317">317</th><td>  <a class="typedef" href="setup.h.html#bool" title='bool' data-type='unsigned char' data-ref="bool">bool</a> <dfn class="decl" id="Curl_transfer_keeper::header" title='Curl_transfer_keeper::header' data-ref="Curl_transfer_keeper::header">header</dfn>;	                <i>/* incoming data has HTTP header */</i></td></tr>
<tr><th id="318">318</th><td>  <b>enum</b> {</td></tr>
<tr><th id="319">319</th><td>    <dfn class="enum" id="Curl_transfer_keeper::HEADER_NORMAL" title='Curl_transfer_keeper::HEADER_NORMAL' data-ref="Curl_transfer_keeper::HEADER_NORMAL">HEADER_NORMAL</dfn>,      <i>/* no bad header at all */</i></td></tr>
<tr><th id="320">320</th><td>    <dfn class="enum" id="Curl_transfer_keeper::HEADER_PARTHEADER" title='Curl_transfer_keeper::HEADER_PARTHEADER' data-ref="Curl_transfer_keeper::HEADER_PARTHEADER">HEADER_PARTHEADER</dfn>,  <i>/* part of the chunk is a bad header, the rest is</i></td></tr>
<tr><th id="321">321</th><td><i>                           normal data */</i></td></tr>
<tr><th id="322">322</th><td>    <dfn class="enum" id="Curl_transfer_keeper::HEADER_ALLBAD" title='Curl_transfer_keeper::HEADER_ALLBAD' data-ref="Curl_transfer_keeper::HEADER_ALLBAD">HEADER_ALLBAD</dfn>       <i>/* all was believed to be header */</i></td></tr>
<tr><th id="323">323</th><td>  } <dfn class="decl" id="Curl_transfer_keeper::badheader" title='Curl_transfer_keeper::badheader' data-ref="Curl_transfer_keeper::badheader">badheader</dfn>;		        <i>/* the header was deemed bad and will be</i></td></tr>
<tr><th id="324">324</th><td><i>                                   written as body */</i></td></tr>
<tr><th id="325">325</th><td>  <em>int</em> <dfn class="decl" id="Curl_transfer_keeper::headerline" title='Curl_transfer_keeper::headerline' data-ref="Curl_transfer_keeper::headerline">headerline</dfn>;		<i>/* counts header lines to better track the</i></td></tr>
<tr><th id="326">326</th><td><i>                                   first one */</i></td></tr>
<tr><th id="327">327</th><td>  <em>char</em> *<dfn class="decl" id="Curl_transfer_keeper::hbufp" title='Curl_transfer_keeper::hbufp' data-ref="Curl_transfer_keeper::hbufp">hbufp</dfn>;			<i>/* points at *end* of header line */</i></td></tr>
<tr><th id="328">328</th><td>  <em>int</em> <dfn class="decl" id="Curl_transfer_keeper::hbuflen" title='Curl_transfer_keeper::hbuflen' data-ref="Curl_transfer_keeper::hbuflen">hbuflen</dfn>;</td></tr>
<tr><th id="329">329</th><td>  <em>char</em> *<dfn class="decl" id="Curl_transfer_keeper::str" title='Curl_transfer_keeper::str' data-ref="Curl_transfer_keeper::str">str</dfn>;			<i>/* within buf */</i></td></tr>
<tr><th id="330">330</th><td>  <em>char</em> *<dfn class="decl" id="Curl_transfer_keeper::str_start" title='Curl_transfer_keeper::str_start' data-ref="Curl_transfer_keeper::str_start">str_start</dfn>;		<i>/* within buf */</i></td></tr>
<tr><th id="331">331</th><td>  <em>char</em> *<dfn class="decl" id="Curl_transfer_keeper::end_ptr" title='Curl_transfer_keeper::end_ptr' data-ref="Curl_transfer_keeper::end_ptr">end_ptr</dfn>;		<i>/* within buf */</i></td></tr>
<tr><th id="332">332</th><td>  <em>char</em> *<dfn class="decl" id="Curl_transfer_keeper::p" title='Curl_transfer_keeper::p' data-ref="Curl_transfer_keeper::p">p</dfn>;			<i>/* within headerbuff */</i></td></tr>
<tr><th id="333">333</th><td>  <a class="typedef" href="setup.h.html#bool" title='bool' data-type='unsigned char' data-ref="bool">bool</a> <dfn class="decl" id="Curl_transfer_keeper::content_range" title='Curl_transfer_keeper::content_range' data-ref="Curl_transfer_keeper::content_range">content_range</dfn>;      	<i>/* set TRUE if Content-Range: was found */</i></td></tr>
<tr><th id="334">334</th><td>  <a class="typedef" href="../include/curl/curl.h.html#curl_off_t" title='curl_off_t' data-type='off_t' data-ref="curl_off_t">curl_off_t</a> <dfn class="decl" id="Curl_transfer_keeper::offset" title='Curl_transfer_keeper::offset' data-ref="Curl_transfer_keeper::offset">offset</dfn>;	                <i>/* possible resume offset read from the</i></td></tr>
<tr><th id="335">335</th><td><i>                                   Content-Range: header */</i></td></tr>
<tr><th id="336">336</th><td>  <em>int</em> <dfn class="decl" id="Curl_transfer_keeper::httpcode" title='Curl_transfer_keeper::httpcode' data-ref="Curl_transfer_keeper::httpcode">httpcode</dfn>;		        <i>/* error code from the 'HTTP/1.? XXX' line */</i></td></tr>
<tr><th id="337">337</th><td>  <em>int</em> <dfn class="decl" id="Curl_transfer_keeper::httpversion" title='Curl_transfer_keeper::httpversion' data-ref="Curl_transfer_keeper::httpversion">httpversion</dfn>;		<i>/* the HTTP version*10 */</i></td></tr>
<tr><th id="338">338</th><td>  <b>struct</b> <a class="type" href="../../../include/x86_64-linux-gnu/bits/time.h.html#timeval" title='timeval' data-ref="timeval">timeval</a> <dfn class="decl" id="Curl_transfer_keeper::start100" title='Curl_transfer_keeper::start100' data-ref="Curl_transfer_keeper::start100">start100</dfn>;      <i>/* time stamp to wait for the 100 code from */</i></td></tr>
<tr><th id="339">339</th><td>  <a class="typedef" href="setup.h.html#bool" title='bool' data-type='unsigned char' data-ref="bool">bool</a> <dfn class="decl" id="Curl_transfer_keeper::write_after_100_header" title='Curl_transfer_keeper::write_after_100_header' data-ref="Curl_transfer_keeper::write_after_100_header">write_after_100_header</dfn>;  <i>/* TRUE = we enable the write after we</i></td></tr>
<tr><th id="340">340</th><td><i>                                   received a 100-continue/timeout or</i></td></tr>
<tr><th id="341">341</th><td><i>                                   FALSE = directly */</i></td></tr>
<tr><th id="342">342</th><td>  <a class="typedef" href="setup.h.html#bool" title='bool' data-type='unsigned char' data-ref="bool">bool</a> <dfn class="decl" id="Curl_transfer_keeper::wait100_after_headers" title='Curl_transfer_keeper::wait100_after_headers' data-ref="Curl_transfer_keeper::wait100_after_headers">wait100_after_headers</dfn>;   <i>/* TRUE = after the request-headers have been</i></td></tr>
<tr><th id="343">343</th><td><i>                                   sent off properly, we go into the wait100</i></td></tr>
<tr><th id="344">344</th><td><i>                                   state, FALSE = don't */</i></td></tr>
<tr><th id="345">345</th><td>  <em>int</em> <dfn class="decl" id="Curl_transfer_keeper::content_encoding" title='Curl_transfer_keeper::content_encoding' data-ref="Curl_transfer_keeper::content_encoding">content_encoding</dfn>;  	<i>/* What content encoding. sec 3.5, RFC2616. */</i></td></tr>
<tr><th id="346">346</th><td></td></tr>
<tr><th id="347">347</th><td><u>#define <dfn class="macro" id="_M/IDENTITY" data-ref="_M/IDENTITY">IDENTITY</dfn> 0		/* No encoding */</u></td></tr>
<tr><th id="348">348</th><td><u>#define <dfn class="macro" id="_M/DEFLATE" data-ref="_M/DEFLATE">DEFLATE</dfn> 1		/* zlib delfate [RFC 1950 &amp; 1951] */</u></td></tr>
<tr><th id="349">349</th><td><u>#define <dfn class="macro" id="_M/GZIP" data-ref="_M/GZIP">GZIP</dfn> 2			/* gzip algorithm [RFC 1952] */</u></td></tr>
<tr><th id="350">350</th><td><u>#define <dfn class="macro" id="_M/COMPRESS" data-ref="_M/COMPRESS">COMPRESS</dfn> 3		/* Not handled, added for completeness */</u></td></tr>
<tr><th id="351">351</th><td></td></tr>
<tr><th id="352">352</th><td><u>#<span data-ppcond="352">ifdef</span> <a class="macro" href="config.h.html#185" data-ref="_M/HAVE_LIBZ">HAVE_LIBZ</a></u></td></tr>
<tr><th id="353">353</th><td>  <a class="typedef" href="setup.h.html#bool" title='bool' data-type='unsigned char' data-ref="bool">bool</a> <dfn class="decl" id="Curl_transfer_keeper::zlib_init" title='Curl_transfer_keeper::zlib_init' data-ref="Curl_transfer_keeper::zlib_init">zlib_init</dfn>;		<i>/* True if zlib already initialized;</i></td></tr>
<tr><th id="354">354</th><td><i>				   undefined if Content-Encoding header. */</i></td></tr>
<tr><th id="355">355</th><td>  <a class="typedef" href="../../../include/zlib.h.html#z_stream" title='z_stream' data-type='struct z_stream_s' data-ref="z_stream">z_stream</a> <dfn class="decl" id="Curl_transfer_keeper::z" title='Curl_transfer_keeper::z' data-ref="Curl_transfer_keeper::z">z</dfn>;			<i>/* State structure for zlib. */</i></td></tr>
<tr><th id="356">356</th><td><u>#<span data-ppcond="352">endif</span></u></td></tr>
<tr><th id="357">357</th><td></td></tr>
<tr><th id="358">358</th><td>  <i>/* for the low speed checks: */</i></td></tr>
<tr><th id="359">359</th><td>  <a class="typedef" href="../../../include/time.h.html#time_t" title='time_t' data-type='__time_t' data-ref="time_t">time_t</a> <dfn class="decl" id="Curl_transfer_keeper::timeofdoc" title='Curl_transfer_keeper::timeofdoc' data-ref="Curl_transfer_keeper::timeofdoc">timeofdoc</dfn>;</td></tr>
<tr><th id="360">360</th><td>  <em>long</em> <dfn class="decl" id="Curl_transfer_keeper::bodywrites" title='Curl_transfer_keeper::bodywrites' data-ref="Curl_transfer_keeper::bodywrites">bodywrites</dfn>;</td></tr>
<tr><th id="361">361</th><td></td></tr>
<tr><th id="362">362</th><td>  <em>char</em> *<dfn class="decl" id="Curl_transfer_keeper::buf" title='Curl_transfer_keeper::buf' data-ref="Curl_transfer_keeper::buf">buf</dfn>;</td></tr>
<tr><th id="363">363</th><td>  <em>char</em> *<dfn class="decl" id="Curl_transfer_keeper::uploadbuf" title='Curl_transfer_keeper::uploadbuf' data-ref="Curl_transfer_keeper::uploadbuf">uploadbuf</dfn>;</td></tr>
<tr><th id="364">364</th><td>  <a class="typedef" href="setup.h.html#curl_socket_t" title='curl_socket_t' data-type='int' data-ref="curl_socket_t">curl_socket_t</a> <dfn class="decl" id="Curl_transfer_keeper::maxfd" title='Curl_transfer_keeper::maxfd' data-ref="Curl_transfer_keeper::maxfd">maxfd</dfn>;</td></tr>
<tr><th id="365">365</th><td></td></tr>
<tr><th id="366">366</th><td>  <i>/* pointers to the actual descriptors we check */</i></td></tr>
<tr><th id="367">367</th><td>  <a class="typedef" href="../../../include/x86_64-linux-gnu/sys/select.h.html#fd_set" title='fd_set' data-type='struct fd_set' data-ref="fd_set">fd_set</a> *<dfn class="decl" id="Curl_transfer_keeper::readfdp" title='Curl_transfer_keeper::readfdp' data-ref="Curl_transfer_keeper::readfdp">readfdp</dfn>;</td></tr>
<tr><th id="368">368</th><td>  <a class="typedef" href="../../../include/x86_64-linux-gnu/sys/select.h.html#fd_set" title='fd_set' data-type='struct fd_set' data-ref="fd_set">fd_set</a> *<dfn class="decl" id="Curl_transfer_keeper::writefdp" title='Curl_transfer_keeper::writefdp' data-ref="Curl_transfer_keeper::writefdp">writefdp</dfn>;</td></tr>
<tr><th id="369">369</th><td></td></tr>
<tr><th id="370">370</th><td>  <i>/* the file descriptors to play with */</i></td></tr>
<tr><th id="371">371</th><td>  <a class="typedef" href="../../../include/x86_64-linux-gnu/sys/select.h.html#fd_set" title='fd_set' data-type='struct fd_set' data-ref="fd_set">fd_set</a> <dfn class="decl" id="Curl_transfer_keeper::readfd" title='Curl_transfer_keeper::readfd' data-ref="Curl_transfer_keeper::readfd">readfd</dfn>;</td></tr>
<tr><th id="372">372</th><td>  <a class="typedef" href="../../../include/x86_64-linux-gnu/sys/select.h.html#fd_set" title='fd_set' data-type='struct fd_set' data-ref="fd_set">fd_set</a> <dfn class="decl" id="Curl_transfer_keeper::writefd" title='Curl_transfer_keeper::writefd' data-ref="Curl_transfer_keeper::writefd">writefd</dfn>;</td></tr>
<tr><th id="373">373</th><td>  <a class="typedef" href="../../../include/x86_64-linux-gnu/sys/select.h.html#fd_set" title='fd_set' data-type='struct fd_set' data-ref="fd_set">fd_set</a> <dfn class="decl" id="Curl_transfer_keeper::rkeepfd" title='Curl_transfer_keeper::rkeepfd' data-ref="Curl_transfer_keeper::rkeepfd">rkeepfd</dfn>;</td></tr>
<tr><th id="374">374</th><td>  <a class="typedef" href="../../../include/x86_64-linux-gnu/sys/select.h.html#fd_set" title='fd_set' data-type='struct fd_set' data-ref="fd_set">fd_set</a> <dfn class="decl" id="Curl_transfer_keeper::wkeepfd" title='Curl_transfer_keeper::wkeepfd' data-ref="Curl_transfer_keeper::wkeepfd">wkeepfd</dfn>;</td></tr>
<tr><th id="375">375</th><td>  <em>int</em> <dfn class="decl" id="Curl_transfer_keeper::keepon" title='Curl_transfer_keeper::keepon' data-ref="Curl_transfer_keeper::keepon">keepon</dfn>;</td></tr>
<tr><th id="376">376</th><td></td></tr>
<tr><th id="377">377</th><td>  <a class="typedef" href="setup.h.html#bool" title='bool' data-type='unsigned char' data-ref="bool">bool</a> <dfn class="decl" id="Curl_transfer_keeper::upload_done" title='Curl_transfer_keeper::upload_done' data-ref="Curl_transfer_keeper::upload_done">upload_done</dfn>; <i>/* set to TRUE when doing chunked transfer-encoding upload</i></td></tr>
<tr><th id="378">378</th><td><i>                       and we're uploading the last chunk */</i></td></tr>
<tr><th id="379">379</th><td></td></tr>
<tr><th id="380">380</th><td>  <a class="typedef" href="setup.h.html#bool" title='bool' data-type='unsigned char' data-ref="bool">bool</a> <dfn class="decl" id="Curl_transfer_keeper::ignorebody" title='Curl_transfer_keeper::ignorebody' data-ref="Curl_transfer_keeper::ignorebody">ignorebody</dfn>;  <i>/* we read a response-body but we ignore it! */</i></td></tr>
<tr><th id="381">381</th><td>};</td></tr>
<tr><th id="382">382</th><td></td></tr>
<tr><th id="383">383</th><td><u>#<span data-ppcond="383">if</span> defined(<span class="macro" data-ref="_M/USE_ARES">USE_ARES</span>) || defined(<span class="macro" data-ref="_M/USE_THREADING_GETHOSTBYNAME">USE_THREADING_GETHOSTBYNAME</span>)</u></td></tr>
<tr><th id="384">384</th><td><b>struct</b> Curl_async {</td></tr>
<tr><th id="385">385</th><td>  <em>char</em> *hostname;</td></tr>
<tr><th id="386">386</th><td>  <em>int</em> port;</td></tr>
<tr><th id="387">387</th><td>  <b>struct</b> Curl_dns_entry *dns;</td></tr>
<tr><th id="388">388</th><td>  bool done;  <i>/* set TRUE when the lookup is complete */</i></td></tr>
<tr><th id="389">389</th><td>  <em>int</em> status; <i>/* if done is TRUE, this is the status from the callback */</i></td></tr>
<tr><th id="390">390</th><td>  <em>void</em> *os_specific;  <i>/* 'struct thread_data' for Windows */</i></td></tr>
<tr><th id="391">391</th><td>};</td></tr>
<tr><th id="392">392</th><td><u>#<span data-ppcond="383">endif</span></u></td></tr>
<tr><th id="393">393</th><td></td></tr>
<tr><th id="394">394</th><td><u>#define <dfn class="macro" id="_M/FIRSTSOCKET" data-ref="_M/FIRSTSOCKET">FIRSTSOCKET</dfn>     0</u></td></tr>
<tr><th id="395">395</th><td><u>#define <dfn class="macro" id="_M/SECONDARYSOCKET" data-ref="_M/SECONDARYSOCKET">SECONDARYSOCKET</dfn> 1</u></td></tr>
<tr><th id="396">396</th><td></td></tr>
<tr><th id="397">397</th><td><i>/*</i></td></tr>
<tr><th id="398">398</th><td><i> * The connectdata struct contains all fields and variables that should be</i></td></tr>
<tr><th id="399">399</th><td><i> * unique for an entire connection.</i></td></tr>
<tr><th id="400">400</th><td><i> */</i></td></tr>
<tr><th id="401">401</th><td><b>struct</b> <dfn class="type def" id="connectdata" title='connectdata' data-ref="connectdata">connectdata</dfn> {</td></tr>
<tr><th id="402">402</th><td>  <i>/**** Fields set when inited and not modified again */</i></td></tr>
<tr><th id="403">403</th><td>  <b>struct</b> <a class="type" href="#SessionHandle" title='SessionHandle' data-ref="SessionHandle">SessionHandle</a> *<dfn class="decl" id="connectdata::data" title='connectdata::data' data-ref="connectdata::data">data</dfn>; <i>/* link to the root CURL struct */</i></td></tr>
<tr><th id="404">404</th><td>  <em>int</em> <dfn class="decl" id="connectdata::connectindex" title='connectdata::connectindex' data-ref="connectdata::connectindex">connectindex</dfn>; <i>/* what index in the connects index this particular</i></td></tr>
<tr><th id="405">405</th><td><i>                       struct has */</i></td></tr>
<tr><th id="406">406</th><td></td></tr>
<tr><th id="407">407</th><td>  <em>long</em> <dfn class="decl" id="connectdata::protocol" title='connectdata::protocol' data-ref="connectdata::protocol">protocol</dfn>; <i>/* PROT_* flags concerning the protocol set */</i></td></tr>
<tr><th id="408">408</th><td><u>#define <dfn class="macro" id="_M/PROT_MISSING" data-ref="_M/PROT_MISSING">PROT_MISSING</dfn> (1&lt;&lt;0)</u></td></tr>
<tr><th id="409">409</th><td><u>#define <dfn class="macro" id="_M/PROT_GOPHER" data-ref="_M/PROT_GOPHER">PROT_GOPHER</dfn>  (1&lt;&lt;1)</u></td></tr>
<tr><th id="410">410</th><td><u>#define <dfn class="macro" id="_M/PROT_HTTP" data-ref="_M/PROT_HTTP">PROT_HTTP</dfn>    (1&lt;&lt;2)</u></td></tr>
<tr><th id="411">411</th><td><u>#define <dfn class="macro" id="_M/PROT_HTTPS" data-ref="_M/PROT_HTTPS">PROT_HTTPS</dfn>   (1&lt;&lt;3)</u></td></tr>
<tr><th id="412">412</th><td><u>#define <dfn class="macro" id="_M/PROT_FTP" data-ref="_M/PROT_FTP">PROT_FTP</dfn>     (1&lt;&lt;4)</u></td></tr>
<tr><th id="413">413</th><td><u>#define <dfn class="macro" id="_M/PROT_TELNET" data-ref="_M/PROT_TELNET">PROT_TELNET</dfn>  (1&lt;&lt;5)</u></td></tr>
<tr><th id="414">414</th><td><u>#define <dfn class="macro" id="_M/PROT_DICT" data-ref="_M/PROT_DICT">PROT_DICT</dfn>    (1&lt;&lt;6)</u></td></tr>
<tr><th id="415">415</th><td><u>#define <dfn class="macro" id="_M/PROT_LDAP" data-ref="_M/PROT_LDAP">PROT_LDAP</dfn>    (1&lt;&lt;7)</u></td></tr>
<tr><th id="416">416</th><td><u>#define <dfn class="macro" id="_M/PROT_FILE" data-ref="_M/PROT_FILE">PROT_FILE</dfn>    (1&lt;&lt;8)</u></td></tr>
<tr><th id="417">417</th><td><u>#define <dfn class="macro" id="_M/PROT_FTPS" data-ref="_M/PROT_FTPS">PROT_FTPS</dfn>    (1&lt;&lt;9)</u></td></tr>
<tr><th id="418">418</th><td><u>#define <dfn class="macro" id="_M/PROT_SSL" data-ref="_M/PROT_SSL">PROT_SSL</dfn>     (1&lt;&lt;10) /* protocol requires SSL */</u></td></tr>
<tr><th id="419">419</th><td></td></tr>
<tr><th id="420">420</th><td>  <i>/* the particular host we use, in two different ways */</i></td></tr>
<tr><th id="421">421</th><td>  <b>struct</b> <a class="type" href="hostip.h.html#Curl_dns_entry" title='Curl_dns_entry' data-ref="Curl_dns_entry">Curl_dns_entry</a> *<dfn class="decl" id="connectdata::connect_addr" title='connectdata::connect_addr' data-ref="connectdata::connect_addr">connect_addr</dfn>;</td></tr>
<tr><th id="422">422</th><td></td></tr>
<tr><th id="423">423</th><td><u>#<span data-ppcond="423">ifdef</span> <span class="macro" data-ref="_M/ENABLE_IPV6">ENABLE_IPV6</span></u></td></tr>
<tr><th id="424">424</th><td>  <b>struct</b> addrinfo *serv_addr;</td></tr>
<tr><th id="425">425</th><td><u>#<span data-ppcond="423">else</span></u></td></tr>
<tr><th id="426">426</th><td>  <b>struct</b> <a class="type" href="../../../include/netinet/in.h.html#sockaddr_in" title='sockaddr_in' data-ref="sockaddr_in">sockaddr_in</a> <dfn class="decl" id="connectdata::serv_addr" title='connectdata::serv_addr' data-ref="connectdata::serv_addr">serv_addr</dfn>;</td></tr>
<tr><th id="427">427</th><td><u>#<span data-ppcond="423">endif</span></u></td></tr>
<tr><th id="428">428</th><td>  <em>char</em> <dfn class="decl" id="connectdata::protostr" title='connectdata::protostr' data-ref="connectdata::protostr">protostr</dfn>[<var>64</var>];  <i>/* store the protocol string in this buffer */</i></td></tr>
<tr><th id="429">429</th><td>  <em>char</em> <dfn class="decl" id="connectdata::gname" title='connectdata::gname' data-ref="connectdata::gname">gname</dfn>[<var>513</var>]; <i>/* store the hostname in this buffer */</i></td></tr>
<tr><th id="430">430</th><td>  <em>char</em> *<dfn class="decl" id="connectdata::name" title='connectdata::name' data-ref="connectdata::name">name</dfn>;      <i>/* host name pointer to fool around with */</i></td></tr>
<tr><th id="431">431</th><td>  <em>char</em> *<dfn class="decl" id="connectdata::path" title='connectdata::path' data-ref="connectdata::path">path</dfn>;      <i>/* allocated buffer to store the URL's path part in */</i></td></tr>
<tr><th id="432">432</th><td>  <em>char</em> *<dfn class="decl" id="connectdata::hostname" title='connectdata::hostname' data-ref="connectdata::hostname">hostname</dfn>;  <i>/* hostname to connect, as parsed from url */</i></td></tr>
<tr><th id="433">433</th><td>  <em>long</em> <dfn class="decl" id="connectdata::port" title='connectdata::port' data-ref="connectdata::port">port</dfn>;       <i>/* which port to use locally */</i></td></tr>
<tr><th id="434">434</th><td>  <em>unsigned</em> <em>short</em> <dfn class="decl" id="connectdata::remote_port" title='connectdata::remote_port' data-ref="connectdata::remote_port">remote_port</dfn>; <i>/* what remote port to connect to,</i></td></tr>
<tr><th id="435">435</th><td><i>                                 not the proxy port! */</i></td></tr>
<tr><th id="436">436</th><td>  <em>char</em> *<dfn class="decl" id="connectdata::ppath" title='connectdata::ppath' data-ref="connectdata::ppath">ppath</dfn>;</td></tr>
<tr><th id="437">437</th><td>  <a class="typedef" href="../include/curl/curl.h.html#curl_off_t" title='curl_off_t' data-type='off_t' data-ref="curl_off_t">curl_off_t</a> <dfn class="decl" id="connectdata::bytecount" title='connectdata::bytecount' data-ref="connectdata::bytecount">bytecount</dfn>;</td></tr>
<tr><th id="438">438</th><td>  <em>long</em> <dfn class="decl" id="connectdata::headerbytecount" title='connectdata::headerbytecount' data-ref="connectdata::headerbytecount">headerbytecount</dfn>;  <i>/* only count received headers */</i></td></tr>
<tr><th id="439">439</th><td></td></tr>
<tr><th id="440">440</th><td>  <em>char</em> *<dfn class="decl" id="connectdata::range" title='connectdata::range' data-ref="connectdata::range">range</dfn>; <i>/* range, if used. See README for detailed specification on</i></td></tr>
<tr><th id="441">441</th><td><i>                  this syntax. */</i></td></tr>
<tr><th id="442">442</th><td>  <a class="typedef" href="../include/curl/curl.h.html#curl_off_t" title='curl_off_t' data-type='off_t' data-ref="curl_off_t">curl_off_t</a> <dfn class="decl" id="connectdata::resume_from" title='connectdata::resume_from' data-ref="connectdata::resume_from">resume_from</dfn>; <i>/* continue [ftp] transfer from here */</i></td></tr>
<tr><th id="443">443</th><td></td></tr>
<tr><th id="444">444</th><td>  <em>char</em> *<dfn class="decl" id="connectdata::proxyhost" title='connectdata::proxyhost' data-ref="connectdata::proxyhost">proxyhost</dfn>; <i>/* name of the http proxy host */</i></td></tr>
<tr><th id="445">445</th><td></td></tr>
<tr><th id="446">446</th><td>  <em>char</em> *<dfn class="decl" id="connectdata::user" title='connectdata::user' data-ref="connectdata::user">user</dfn>;    <i>/* user name string, allocated */</i></td></tr>
<tr><th id="447">447</th><td>  <em>char</em> *<dfn class="decl" id="connectdata::passwd" title='connectdata::passwd' data-ref="connectdata::passwd">passwd</dfn>;  <i>/* password string, allocated */</i></td></tr>
<tr><th id="448">448</th><td></td></tr>
<tr><th id="449">449</th><td>  <em>char</em> *<dfn class="decl" id="connectdata::proxyuser" title='connectdata::proxyuser' data-ref="connectdata::proxyuser">proxyuser</dfn>;    <i>/* proxy user name string, allocated */</i></td></tr>
<tr><th id="450">450</th><td>  <em>char</em> *<dfn class="decl" id="connectdata::proxypasswd" title='connectdata::proxypasswd' data-ref="connectdata::proxypasswd">proxypasswd</dfn>;  <i>/* proxy password string, allocated */</i></td></tr>
<tr><th id="451">451</th><td>  </td></tr>
<tr><th id="452">452</th><td>  <b>struct</b> <a class="type" href="../../../include/x86_64-linux-gnu/bits/time.h.html#timeval" title='timeval' data-ref="timeval">timeval</a> <dfn class="decl" id="connectdata::now" title='connectdata::now' data-ref="connectdata::now">now</dfn>;     <i>/* "current" time */</i></td></tr>
<tr><th id="453">453</th><td>  <b>struct</b> <a class="type" href="../../../include/x86_64-linux-gnu/bits/time.h.html#timeval" title='timeval' data-ref="timeval">timeval</a> <dfn class="decl" id="connectdata::created" title='connectdata::created' data-ref="connectdata::created">created</dfn>; <i>/* creation time */</i></td></tr>
<tr><th id="454">454</th><td>  <a class="typedef" href="setup.h.html#curl_socket_t" title='curl_socket_t' data-type='int' data-ref="curl_socket_t">curl_socket_t</a> <dfn class="decl" id="connectdata::sock" title='connectdata::sock' data-ref="connectdata::sock">sock</dfn>[<var>2</var>]; <i>/* two sockets, the second is used for the data</i></td></tr>
<tr><th id="455">455</th><td><i>                            transfer when doing FTP */</i></td></tr>
<tr><th id="456">456</th><td>  <a class="typedef" href="../include/curl/curl.h.html#curl_off_t" title='curl_off_t' data-type='off_t' data-ref="curl_off_t">curl_off_t</a> <dfn class="decl" id="connectdata::maxdownload" title='connectdata::maxdownload' data-ref="connectdata::maxdownload">maxdownload</dfn>; <i>/* in bytes, the maximum amount of data to fetch, 0</i></td></tr>
<tr><th id="457">457</th><td><i>                             means unlimited */</i></td></tr>
<tr><th id="458">458</th><td>  </td></tr>
<tr><th id="459">459</th><td>  <b>struct</b> <a class="type" href="#ssl_connect_data" title='ssl_connect_data' data-ref="ssl_connect_data">ssl_connect_data</a> <dfn class="decl" id="connectdata::ssl" title='connectdata::ssl' data-ref="connectdata::ssl">ssl</dfn>[<var>2</var>]; <i>/* this is for ssl-stuff */</i></td></tr>
<tr><th id="460">460</th><td>  <b>struct</b> <a class="type" href="#ssl_config_data" title='ssl_config_data' data-ref="ssl_config_data">ssl_config_data</a> <dfn class="decl" id="connectdata::ssl_config" title='connectdata::ssl_config' data-ref="connectdata::ssl_config">ssl_config</dfn>;</td></tr>
<tr><th id="461">461</th><td></td></tr>
<tr><th id="462">462</th><td>  <b>struct</b> <a class="type" href="#ConnectBits" title='ConnectBits' data-ref="ConnectBits">ConnectBits</a> <dfn class="decl" id="connectdata::bits" title='connectdata::bits' data-ref="connectdata::bits">bits</dfn>;    <i>/* various state-flags for this connection */</i></td></tr>
<tr><th id="463">463</th><td></td></tr>
<tr><th id="464">464</th><td>  <i>/* These two functions MUST be set by the curl_connect() function to be</i></td></tr>
<tr><th id="465">465</th><td><i>     be protocol dependent */</i></td></tr>
<tr><th id="466">466</th><td>  <a class="typedef" href="../include/curl/curl.h.html#CURLcode" title='CURLcode' data-type='enum CURLcode' data-ref="CURLcode">CURLcode</a> (*<dfn class="decl" id="connectdata::curl_do" title='connectdata::curl_do' data-ref="connectdata::curl_do">curl_do</dfn>)(<b>struct</b> <a class="type" href="#connectdata" title='connectdata' data-ref="connectdata">connectdata</a> *);</td></tr>
<tr><th id="467">467</th><td>  <a class="typedef" href="../include/curl/curl.h.html#CURLcode" title='CURLcode' data-type='enum CURLcode' data-ref="CURLcode">CURLcode</a> (*<dfn class="decl" id="connectdata::curl_done" title='connectdata::curl_done' data-ref="connectdata::curl_done">curl_done</dfn>)(<b>struct</b> <a class="type" href="#connectdata" title='connectdata' data-ref="connectdata">connectdata</a> *);</td></tr>
<tr><th id="468">468</th><td></td></tr>
<tr><th id="469">469</th><td>  <i>/* If the curl_do() function is better made in two halves, this</i></td></tr>
<tr><th id="470">470</th><td><i>   * curl_do_more() function will be called afterwards, if set. For example</i></td></tr>
<tr><th id="471">471</th><td><i>   * for doing the FTP stuff after the PASV/PORT command.</i></td></tr>
<tr><th id="472">472</th><td><i>   */</i></td></tr>
<tr><th id="473">473</th><td>  <a class="typedef" href="../include/curl/curl.h.html#CURLcode" title='CURLcode' data-type='enum CURLcode' data-ref="CURLcode">CURLcode</a> (*<dfn class="decl" id="connectdata::curl_do_more" title='connectdata::curl_do_more' data-ref="connectdata::curl_do_more">curl_do_more</dfn>)(<b>struct</b> <a class="type" href="#connectdata" title='connectdata' data-ref="connectdata">connectdata</a> *);</td></tr>
<tr><th id="474">474</th><td></td></tr>
<tr><th id="475">475</th><td>  <i>/* This function *MAY* be set to a protocol-dependent function that is run</i></td></tr>
<tr><th id="476">476</th><td><i>   * after the connect() and everything is done, as a step in the connection.</i></td></tr>
<tr><th id="477">477</th><td><i>   */</i> </td></tr>
<tr><th id="478">478</th><td>  <a class="typedef" href="../include/curl/curl.h.html#CURLcode" title='CURLcode' data-type='enum CURLcode' data-ref="CURLcode">CURLcode</a> (*<dfn class="decl" id="connectdata::curl_connect" title='connectdata::curl_connect' data-ref="connectdata::curl_connect">curl_connect</dfn>)(<b>struct</b> <a class="type" href="#connectdata" title='connectdata' data-ref="connectdata">connectdata</a> *);</td></tr>
<tr><th id="479">479</th><td></td></tr>
<tr><th id="480">480</th><td>  <i>/* This function *MAY* be set to a protocol-dependent function that is run</i></td></tr>
<tr><th id="481">481</th><td><i>   * by the curl_disconnect(), as a step in the disconnection.</i></td></tr>
<tr><th id="482">482</th><td><i>   */</i> </td></tr>
<tr><th id="483">483</th><td>  <a class="typedef" href="../include/curl/curl.h.html#CURLcode" title='CURLcode' data-type='enum CURLcode' data-ref="CURLcode">CURLcode</a> (*<dfn class="decl" id="connectdata::curl_disconnect" title='connectdata::curl_disconnect' data-ref="connectdata::curl_disconnect">curl_disconnect</dfn>)(<b>struct</b> <a class="type" href="#connectdata" title='connectdata' data-ref="connectdata">connectdata</a> *);</td></tr>
<tr><th id="484">484</th><td></td></tr>
<tr><th id="485">485</th><td>  <i>/* This function *MAY* be set to a protocol-dependent function that is run</i></td></tr>
<tr><th id="486">486</th><td><i>   * in the curl_close() function if protocol-specific cleanups are required.</i></td></tr>
<tr><th id="487">487</th><td><i>   */</i> </td></tr>
<tr><th id="488">488</th><td>  <a class="typedef" href="../include/curl/curl.h.html#CURLcode" title='CURLcode' data-type='enum CURLcode' data-ref="CURLcode">CURLcode</a> (*<dfn class="decl" id="connectdata::curl_close" title='connectdata::curl_close' data-ref="connectdata::curl_close">curl_close</dfn>)(<b>struct</b> <a class="type" href="#connectdata" title='connectdata' data-ref="connectdata">connectdata</a> *);</td></tr>
<tr><th id="489">489</th><td></td></tr>
<tr><th id="490">490</th><td>  <i>/**** curl_get() phase fields */</i></td></tr>
<tr><th id="491">491</th><td></td></tr>
<tr><th id="492">492</th><td>  <i>/* READ stuff */</i></td></tr>
<tr><th id="493">493</th><td>  <a class="typedef" href="setup.h.html#curl_socket_t" title='curl_socket_t' data-type='int' data-ref="curl_socket_t">curl_socket_t</a> <dfn class="decl" id="connectdata::sockfd" title='connectdata::sockfd' data-ref="connectdata::sockfd">sockfd</dfn>;	  <i>/* socket to read from or CURL_SOCKET_BAD */</i></td></tr>
<tr><th id="494">494</th><td>  <a class="typedef" href="../include/curl/curl.h.html#curl_off_t" title='curl_off_t' data-type='off_t' data-ref="curl_off_t">curl_off_t</a> <dfn class="decl" id="connectdata::size" title='connectdata::size' data-ref="connectdata::size">size</dfn>;	  <i>/* -1 if unknown at this point */</i></td></tr>
<tr><th id="495">495</th><td>  <a class="typedef" href="../include/curl/curl.h.html#curl_off_t" title='curl_off_t' data-type='off_t' data-ref="curl_off_t">curl_off_t</a> *<dfn class="decl" id="connectdata::bytecountp" title='connectdata::bytecountp' data-ref="connectdata::bytecountp">bytecountp</dfn>; <i>/* return number of bytes read or NULL */</i></td></tr>
<tr><th id="496">496</th><td>          </td></tr>
<tr><th id="497">497</th><td>  <i>/* WRITE stuff */</i></td></tr>
<tr><th id="498">498</th><td>  <a class="typedef" href="setup.h.html#curl_socket_t" title='curl_socket_t' data-type='int' data-ref="curl_socket_t">curl_socket_t</a> <dfn class="decl" id="connectdata::writesockfd" title='connectdata::writesockfd' data-ref="connectdata::writesockfd">writesockfd</dfn>; <i>/* socket to write to, it may very</i></td></tr>
<tr><th id="499">499</th><td><i>                                well be the same we read from.</i></td></tr>
<tr><th id="500">500</th><td><i>                                CURL_SOCKET_BAD disables */</i></td></tr>
<tr><th id="501">501</th><td>  <a class="typedef" href="../include/curl/curl.h.html#curl_off_t" title='curl_off_t' data-type='off_t' data-ref="curl_off_t">curl_off_t</a> *<dfn class="decl" id="connectdata::writebytecountp" title='connectdata::writebytecountp' data-ref="connectdata::writebytecountp">writebytecountp</dfn>; <i>/* return number of bytes written or NULL */</i></td></tr>
<tr><th id="502">502</th><td></td></tr>
<tr><th id="503">503</th><td>  <i class="doc">/** Dynamicly allocated strings, may need to be freed before this **/</i></td></tr>
<tr><th id="504">504</th><td>  <i class="doc">/** struct is killed.                                             **/</i></td></tr>
<tr><th id="505">505</th><td>  <b>struct</b> <dfn class="type def" id="dynamically_allocated_data" title='dynamically_allocated_data' data-ref="dynamically_allocated_data"><a class="type" href="#dynamically_allocated_data" title='dynamically_allocated_data' data-ref="dynamically_allocated_data">dynamically_allocated_data</a></dfn> {</td></tr>
<tr><th id="506">506</th><td>    <em>char</em> *<dfn class="decl" id="dynamically_allocated_data::proxyuserpwd" title='dynamically_allocated_data::proxyuserpwd' data-ref="dynamically_allocated_data::proxyuserpwd">proxyuserpwd</dfn>; <i>/* free later if not NULL! */</i></td></tr>
<tr><th id="507">507</th><td>    <em>char</em> *<dfn class="decl" id="dynamically_allocated_data::uagent" title='dynamically_allocated_data::uagent' data-ref="dynamically_allocated_data::uagent">uagent</dfn>; <i>/* free later if not NULL! */</i></td></tr>
<tr><th id="508">508</th><td>    <em>char</em> *<dfn class="decl" id="dynamically_allocated_data::accept_encoding" title='dynamically_allocated_data::accept_encoding' data-ref="dynamically_allocated_data::accept_encoding">accept_encoding</dfn>; <i>/* free later if not NULL! */</i></td></tr>
<tr><th id="509">509</th><td>    <em>char</em> *<dfn class="decl" id="dynamically_allocated_data::userpwd" title='dynamically_allocated_data::userpwd' data-ref="dynamically_allocated_data::userpwd">userpwd</dfn>; <i>/* free later if not NULL! */</i></td></tr>
<tr><th id="510">510</th><td>    <em>char</em> *<dfn class="decl" id="dynamically_allocated_data::rangeline" title='dynamically_allocated_data::rangeline' data-ref="dynamically_allocated_data::rangeline">rangeline</dfn>; <i>/* free later if not NULL! */</i></td></tr>
<tr><th id="511">511</th><td>    <em>char</em> *<dfn class="decl" id="dynamically_allocated_data::ref" title='dynamically_allocated_data::ref' data-ref="dynamically_allocated_data::ref">ref</dfn>; <i>/* free later if not NULL! */</i></td></tr>
<tr><th id="512">512</th><td>    <em>char</em> *<dfn class="decl" id="dynamically_allocated_data::cookie" title='dynamically_allocated_data::cookie' data-ref="dynamically_allocated_data::cookie">cookie</dfn>; <i>/* free later if not NULL! */</i></td></tr>
<tr><th id="513">513</th><td>    <em>char</em> *<dfn class="decl" id="dynamically_allocated_data::host" title='dynamically_allocated_data::host' data-ref="dynamically_allocated_data::host">host</dfn>; <i>/* free later if not NULL */</i></td></tr>
<tr><th id="514">514</th><td>    <em>char</em> *<dfn class="decl" id="dynamically_allocated_data::cookiehost" title='dynamically_allocated_data::cookiehost' data-ref="dynamically_allocated_data::cookiehost">cookiehost</dfn>; <i>/* free later if not NULL */</i></td></tr>
<tr><th id="515">515</th><td>  } <dfn class="decl" id="connectdata::allocptr" title='connectdata::allocptr' data-ref="connectdata::allocptr">allocptr</dfn>;</td></tr>
<tr><th id="516">516</th><td></td></tr>
<tr><th id="517">517</th><td>  <em>char</em> *<dfn class="decl" id="connectdata::newurl" title='connectdata::newurl' data-ref="connectdata::newurl">newurl</dfn>; <i>/* This can only be set if a Location: was in the</i></td></tr>
<tr><th id="518">518</th><td><i>		   document headers */</i></td></tr>
<tr><th id="519">519</th><td></td></tr>
<tr><th id="520">520</th><td><u>#<span data-ppcond="520">ifdef</span> <span class="macro" data-ref="_M/HAVE_KRB4">HAVE_KRB4</span></u></td></tr>
<tr><th id="521">521</th><td>  <b>enum</b> protection_level command_prot;</td></tr>
<tr><th id="522">522</th><td>  <b>enum</b> protection_level data_prot;</td></tr>
<tr><th id="523">523</th><td>  <b>enum</b> protection_level request_data_prot;</td></tr>
<tr><th id="524">524</th><td></td></tr>
<tr><th id="525">525</th><td>  size_t buffer_size;</td></tr>
<tr><th id="526">526</th><td></td></tr>
<tr><th id="527">527</th><td>  <b>struct</b> krb4buffer in_buffer, out_buffer;</td></tr>
<tr><th id="528">528</th><td>  <em>int</em> sec_complete;</td></tr>
<tr><th id="529">529</th><td>  <em>void</em> *app_data;</td></tr>
<tr><th id="530">530</th><td></td></tr>
<tr><th id="531">531</th><td>  <b>struct</b> Curl_sec_client_mech *mech;</td></tr>
<tr><th id="532">532</th><td>  <b>struct</b> sockaddr_in local_addr;</td></tr>
<tr><th id="533">533</th><td></td></tr>
<tr><th id="534">534</th><td><u>#<span data-ppcond="520">endif</span></u></td></tr>
<tr><th id="535">535</th><td></td></tr>
<tr><th id="536">536</th><td>  <i>/*************** Request - specific items ************/</i></td></tr>
<tr><th id="537">537</th><td>  <i>/* previously this was in the urldata struct */</i></td></tr>
<tr><th id="538">538</th><td>  <b>union</b> {</td></tr>
<tr><th id="539">539</th><td>    <b>struct</b> <a class="type" href="#HTTP" title='HTTP' data-ref="HTTP">HTTP</a> *<dfn class="decl" id="connectdata::(anonymous)::http" title='connectdata::(anonymous union)::http' data-ref="connectdata::(anonymous)::http">http</dfn>;</td></tr>
<tr><th id="540">540</th><td>    <b>struct</b> <a class="type" href="#HTTP" title='HTTP' data-ref="HTTP">HTTP</a> *<dfn class="decl" id="connectdata::(anonymous)::gopher" title='connectdata::(anonymous union)::gopher' data-ref="connectdata::(anonymous)::gopher">gopher</dfn>; <i>/* alias, just for the sake of being more readable */</i></td></tr>
<tr><th id="541">541</th><td>    <b>struct</b> <a class="type" href="#HTTP" title='HTTP' data-ref="HTTP">HTTP</a> *<dfn class="decl" id="connectdata::(anonymous)::https" title='connectdata::(anonymous union)::https' data-ref="connectdata::(anonymous)::https">https</dfn>;  <i>/* alias, just for the sake of being more readable */</i></td></tr>
<tr><th id="542">542</th><td>    <b>struct</b> <a class="type" href="#FTP" title='FTP' data-ref="FTP">FTP</a> *<dfn class="decl" id="connectdata::(anonymous)::ftp" title='connectdata::(anonymous union)::ftp' data-ref="connectdata::(anonymous)::ftp">ftp</dfn>;</td></tr>
<tr><th id="543">543</th><td>    <b>struct</b> <a class="type" href="#FILEPROTO" title='FILEPROTO' data-ref="FILEPROTO">FILEPROTO</a> *<dfn class="decl" id="connectdata::(anonymous)::file" title='connectdata::(anonymous union)::file' data-ref="connectdata::(anonymous)::file">file</dfn>;</td></tr>
<tr><th id="544">544</th><td>    <em>void</em> *<dfn class="decl" id="connectdata::(anonymous)::telnet" title='connectdata::(anonymous union)::telnet' data-ref="connectdata::(anonymous)::telnet">telnet</dfn>;        <i>/* private for telnet.c-eyes only */</i></td></tr>
<tr><th id="545">545</th><td><u>#<span data-ppcond="545">if</span> 0 /* no need for special ones for these: */</u></td></tr>
<tr><th id="546">546</th><td>    <b>struct</b> LDAP *ldap;</td></tr>
<tr><th id="547">547</th><td>    <b>struct</b> DICT *dict;</td></tr>
<tr><th id="548">548</th><td><u>#<span data-ppcond="545">endif</span></u></td></tr>
<tr><th id="549">549</th><td>    <em>void</em> *<dfn class="decl" id="connectdata::(anonymous)::generic" title='connectdata::(anonymous union)::generic' data-ref="connectdata::(anonymous)::generic">generic</dfn>;</td></tr>
<tr><th id="550">550</th><td>  } <dfn class="decl" id="connectdata::proto" title='connectdata::proto' data-ref="connectdata::proto">proto</dfn>;</td></tr>
<tr><th id="551">551</th><td></td></tr>
<tr><th id="552">552</th><td>  <i>/* This struct is inited when needed */</i></td></tr>
<tr><th id="553">553</th><td>  <b>struct</b> <a class="type" href="#Curl_transfer_keeper" title='Curl_transfer_keeper' data-ref="Curl_transfer_keeper">Curl_transfer_keeper</a> <dfn class="decl" id="connectdata::keep" title='connectdata::keep' data-ref="connectdata::keep">keep</dfn>;</td></tr>
<tr><th id="554">554</th><td></td></tr>
<tr><th id="555">555</th><td>  <i>/* 'upload_present' is used to keep a byte counter of how much data there is</i></td></tr>
<tr><th id="556">556</th><td><i>     still left in the buffer, aimed for upload. */</i></td></tr>
<tr><th id="557">557</th><td>  <em>int</em> <dfn class="decl" id="connectdata::upload_present" title='connectdata::upload_present' data-ref="connectdata::upload_present">upload_present</dfn>;</td></tr>
<tr><th id="558">558</th><td></td></tr>
<tr><th id="559">559</th><td>   <i>/* 'upload_fromhere' is used as a read-pointer when we uploaded parts of a</i></td></tr>
<tr><th id="560">560</th><td><i>      buffer, so the next read should read from where this pointer points to,</i></td></tr>
<tr><th id="561">561</th><td><i>      and the 'upload_present' contains the number of bytes available at this</i></td></tr>
<tr><th id="562">562</th><td><i>      position */</i></td></tr>
<tr><th id="563">563</th><td>  <em>char</em> *<dfn class="decl" id="connectdata::upload_fromhere" title='connectdata::upload_fromhere' data-ref="connectdata::upload_fromhere">upload_fromhere</dfn>;</td></tr>
<tr><th id="564">564</th><td></td></tr>
<tr><th id="565">565</th><td>  <a class="typedef" href="../include/curl/curl.h.html#curl_read_callback" title='curl_read_callback' data-type='size_t (*)(char *, size_t, size_t, void *)' data-ref="curl_read_callback">curl_read_callback</a> <dfn class="decl" id="connectdata::fread" title='connectdata::fread' data-ref="connectdata::fread">fread</dfn>; <i>/* function that reads the input */</i></td></tr>
<tr><th id="566">566</th><td>  <em>void</em> *<dfn class="decl" id="connectdata::fread_in" title='connectdata::fread_in' data-ref="connectdata::fread_in">fread_in</dfn>;           <i>/* pointer to pass to the fread() above */</i></td></tr>
<tr><th id="567">567</th><td></td></tr>
<tr><th id="568">568</th><td>  <b>struct</b> <a class="type" href="#ntlmdata" title='ntlmdata' data-ref="ntlmdata">ntlmdata</a> <dfn class="decl" id="connectdata::ntlm" title='connectdata::ntlm' data-ref="connectdata::ntlm">ntlm</dfn>;     <i>/* NTLM differs from other authentication schemes</i></td></tr>
<tr><th id="569">569</th><td><i>                               because it authenticates connections, not</i></td></tr>
<tr><th id="570">570</th><td><i>                               single requests! */</i></td></tr>
<tr><th id="571">571</th><td>  <b>struct</b> <a class="type" href="#ntlmdata" title='ntlmdata' data-ref="ntlmdata">ntlmdata</a> <dfn class="decl" id="connectdata::proxyntlm" title='connectdata::proxyntlm' data-ref="connectdata::proxyntlm">proxyntlm</dfn>; <i>/* NTLM data for proxy */</i></td></tr>
<tr><th id="572">572</th><td></td></tr>
<tr><th id="573">573</th><td>  <em>int</em> <dfn class="decl" id="connectdata::sockerror" title='connectdata::sockerror' data-ref="connectdata::sockerror">sockerror</dfn>; <i>/* errno stored by Curl_read() if the underlying layer returns</i></td></tr>
<tr><th id="574">574</th><td><i>                    error */</i></td></tr>
<tr><th id="575">575</th><td><u>#<span data-ppcond="575">if</span> defined(<span class="macro" data-ref="_M/USE_ARES">USE_ARES</span>) || defined(<span class="macro" data-ref="_M/USE_THREADING_GETHOSTBYNAME">USE_THREADING_GETHOSTBYNAME</span>)</u></td></tr>
<tr><th id="576">576</th><td>  <i>/* data used for the asynch name resolve callback */</i></td></tr>
<tr><th id="577">577</th><td>  <b>struct</b> Curl_async async;</td></tr>
<tr><th id="578">578</th><td><u>#<span data-ppcond="575">endif</span></u></td></tr>
<tr><th id="579">579</th><td>};</td></tr>
<tr><th id="580">580</th><td></td></tr>
<tr><th id="581">581</th><td><i>/* The end of connectdata. */</i></td></tr>
<tr><th id="582">582</th><td></td></tr>
<tr><th id="583">583</th><td><i>/*</i></td></tr>
<tr><th id="584">584</th><td><i> * Struct to keep statistical and informational data.</i></td></tr>
<tr><th id="585">585</th><td><i> */</i></td></tr>
<tr><th id="586">586</th><td><b>struct</b> <dfn class="type def" id="PureInfo" title='PureInfo' data-ref="PureInfo">PureInfo</dfn> {</td></tr>
<tr><th id="587">587</th><td>  <em>int</em> <dfn class="decl" id="PureInfo::httpcode" title='PureInfo::httpcode' data-ref="PureInfo::httpcode">httpcode</dfn>;  <i>/* Recent HTTP or FTP response code */</i></td></tr>
<tr><th id="588">588</th><td>  <em>int</em> <dfn class="decl" id="PureInfo::httpproxycode" title='PureInfo::httpproxycode' data-ref="PureInfo::httpproxycode">httpproxycode</dfn>;</td></tr>
<tr><th id="589">589</th><td>  <em>int</em> <dfn class="decl" id="PureInfo::httpversion" title='PureInfo::httpversion' data-ref="PureInfo::httpversion">httpversion</dfn>;</td></tr>
<tr><th id="590">590</th><td>  <em>long</em> <dfn class="decl" id="PureInfo::filetime" title='PureInfo::filetime' data-ref="PureInfo::filetime">filetime</dfn>; <i>/* If requested, this is might get set. Set to -1 if the time</i></td></tr>
<tr><th id="591">591</th><td><i>                    was unretrievable. We cannot have this of type time_t,</i></td></tr>
<tr><th id="592">592</th><td><i>                    since time_t is unsigned on several platforms such as</i></td></tr>
<tr><th id="593">593</th><td><i>                    OpenVMS. */</i></td></tr>
<tr><th id="594">594</th><td>  <em>long</em> <dfn class="decl" id="PureInfo::header_size" title='PureInfo::header_size' data-ref="PureInfo::header_size">header_size</dfn>;  <i>/* size of read header(s) in bytes */</i></td></tr>
<tr><th id="595">595</th><td>  <em>long</em> <dfn class="decl" id="PureInfo::request_size" title='PureInfo::request_size' data-ref="PureInfo::request_size">request_size</dfn>; <i>/* the amount of bytes sent in the request(s) */</i></td></tr>
<tr><th id="596">596</th><td></td></tr>
<tr><th id="597">597</th><td>  <em>long</em> <dfn class="decl" id="PureInfo::proxyauthavail" title='PureInfo::proxyauthavail' data-ref="PureInfo::proxyauthavail">proxyauthavail</dfn>;</td></tr>
<tr><th id="598">598</th><td>  <em>long</em> <dfn class="decl" id="PureInfo::httpauthavail" title='PureInfo::httpauthavail' data-ref="PureInfo::httpauthavail">httpauthavail</dfn>;</td></tr>
<tr><th id="599">599</th><td></td></tr>
<tr><th id="600">600</th><td>  <em>char</em> *<dfn class="decl" id="PureInfo::contenttype" title='PureInfo::contenttype' data-ref="PureInfo::contenttype">contenttype</dfn>; <i>/* the content type of the object */</i></td></tr>
<tr><th id="601">601</th><td>};</td></tr>
<tr><th id="602">602</th><td></td></tr>
<tr><th id="603">603</th><td></td></tr>
<tr><th id="604">604</th><td><b>struct</b> <dfn class="type def" id="Progress" title='Progress' data-ref="Progress">Progress</dfn> {</td></tr>
<tr><th id="605">605</th><td>  <em>long</em> <dfn class="decl" id="Progress::lastshow" title='Progress::lastshow' data-ref="Progress::lastshow">lastshow</dfn>; <i>/* time() of the last displayed progress meter or NULL to</i></td></tr>
<tr><th id="606">606</th><td><i>                    force redraw at next call */</i></td></tr>
<tr><th id="607">607</th><td>  <a class="typedef" href="../include/curl/curl.h.html#curl_off_t" title='curl_off_t' data-type='off_t' data-ref="curl_off_t">curl_off_t</a> <dfn class="decl" id="Progress::size_dl" title='Progress::size_dl' data-ref="Progress::size_dl">size_dl</dfn>; <i>/* total expected size */</i></td></tr>
<tr><th id="608">608</th><td>  <a class="typedef" href="../include/curl/curl.h.html#curl_off_t" title='curl_off_t' data-type='off_t' data-ref="curl_off_t">curl_off_t</a> <dfn class="decl" id="Progress::size_ul" title='Progress::size_ul' data-ref="Progress::size_ul">size_ul</dfn>; <i>/* total expected size */</i></td></tr>
<tr><th id="609">609</th><td>  <a class="typedef" href="../include/curl/curl.h.html#curl_off_t" title='curl_off_t' data-type='off_t' data-ref="curl_off_t">curl_off_t</a> <dfn class="decl" id="Progress::downloaded" title='Progress::downloaded' data-ref="Progress::downloaded">downloaded</dfn>; <i>/* transfered so far */</i></td></tr>
<tr><th id="610">610</th><td>  <a class="typedef" href="../include/curl/curl.h.html#curl_off_t" title='curl_off_t' data-type='off_t' data-ref="curl_off_t">curl_off_t</a> <dfn class="decl" id="Progress::uploaded" title='Progress::uploaded' data-ref="Progress::uploaded">uploaded</dfn>; <i>/* transfered so far */</i></td></tr>
<tr><th id="611">611</th><td></td></tr>
<tr><th id="612">612</th><td>  <a class="typedef" href="../include/curl/curl.h.html#curl_off_t" title='curl_off_t' data-type='off_t' data-ref="curl_off_t">curl_off_t</a> <dfn class="decl" id="Progress::current_speed" title='Progress::current_speed' data-ref="Progress::current_speed">current_speed</dfn>; <i>/* uses the currently fastest transfer */</i></td></tr>
<tr><th id="613">613</th><td></td></tr>
<tr><th id="614">614</th><td>  <a class="typedef" href="setup.h.html#bool" title='bool' data-type='unsigned char' data-ref="bool">bool</a> <dfn class="decl" id="Progress::callback" title='Progress::callback' data-ref="Progress::callback">callback</dfn>;  <i>/* set when progress callback is used */</i></td></tr>
<tr><th id="615">615</th><td>  <em>int</em> <dfn class="decl" id="Progress::width" title='Progress::width' data-ref="Progress::width">width</dfn>; <i>/* screen width at download start */</i></td></tr>
<tr><th id="616">616</th><td>  <em>int</em> <dfn class="decl" id="Progress::flags" title='Progress::flags' data-ref="Progress::flags">flags</dfn>; <i>/* see progress.h */</i></td></tr>
<tr><th id="617">617</th><td></td></tr>
<tr><th id="618">618</th><td>  <em>double</em> <dfn class="decl" id="Progress::timespent" title='Progress::timespent' data-ref="Progress::timespent">timespent</dfn>;</td></tr>
<tr><th id="619">619</th><td></td></tr>
<tr><th id="620">620</th><td>  <a class="typedef" href="../include/curl/curl.h.html#curl_off_t" title='curl_off_t' data-type='off_t' data-ref="curl_off_t">curl_off_t</a> <dfn class="decl" id="Progress::dlspeed" title='Progress::dlspeed' data-ref="Progress::dlspeed">dlspeed</dfn>;</td></tr>
<tr><th id="621">621</th><td>  <a class="typedef" href="../include/curl/curl.h.html#curl_off_t" title='curl_off_t' data-type='off_t' data-ref="curl_off_t">curl_off_t</a> <dfn class="decl" id="Progress::ulspeed" title='Progress::ulspeed' data-ref="Progress::ulspeed">ulspeed</dfn>;</td></tr>
<tr><th id="622">622</th><td></td></tr>
<tr><th id="623">623</th><td>  <em>double</em> <dfn class="decl" id="Progress::t_nslookup" title='Progress::t_nslookup' data-ref="Progress::t_nslookup">t_nslookup</dfn>;</td></tr>
<tr><th id="624">624</th><td>  <em>double</em> <dfn class="decl" id="Progress::t_connect" title='Progress::t_connect' data-ref="Progress::t_connect">t_connect</dfn>;</td></tr>
<tr><th id="625">625</th><td>  <em>double</em> <dfn class="decl" id="Progress::t_pretransfer" title='Progress::t_pretransfer' data-ref="Progress::t_pretransfer">t_pretransfer</dfn>;</td></tr>
<tr><th id="626">626</th><td>  <em>double</em> <dfn class="decl" id="Progress::t_starttransfer" title='Progress::t_starttransfer' data-ref="Progress::t_starttransfer">t_starttransfer</dfn>;</td></tr>
<tr><th id="627">627</th><td>  <em>double</em> <dfn class="decl" id="Progress::t_redirect" title='Progress::t_redirect' data-ref="Progress::t_redirect">t_redirect</dfn>;</td></tr>
<tr><th id="628">628</th><td></td></tr>
<tr><th id="629">629</th><td>  <b>struct</b> <a class="type" href="../../../include/x86_64-linux-gnu/bits/time.h.html#timeval" title='timeval' data-ref="timeval">timeval</a> <dfn class="decl" id="Progress::start" title='Progress::start' data-ref="Progress::start">start</dfn>;</td></tr>
<tr><th id="630">630</th><td>  <b>struct</b> <a class="type" href="../../../include/x86_64-linux-gnu/bits/time.h.html#timeval" title='timeval' data-ref="timeval">timeval</a> <dfn class="decl" id="Progress::t_startsingle" title='Progress::t_startsingle' data-ref="Progress::t_startsingle">t_startsingle</dfn>;</td></tr>
<tr><th id="631">631</th><td><u>#define <dfn class="macro" id="_M/CURR_TIME" data-ref="_M/CURR_TIME">CURR_TIME</dfn> (5+1) /* 6 entries for 5 seconds */</u></td></tr>
<tr><th id="632">632</th><td></td></tr>
<tr><th id="633">633</th><td>  <a class="typedef" href="../include/curl/curl.h.html#curl_off_t" title='curl_off_t' data-type='off_t' data-ref="curl_off_t">curl_off_t</a> <dfn class="decl" id="Progress::speeder" title='Progress::speeder' data-ref="Progress::speeder">speeder</dfn>[ <a class="macro" href="#631" title="(5+1)" data-ref="_M/CURR_TIME">CURR_TIME</a> ];</td></tr>
<tr><th id="634">634</th><td>  <b>struct</b> <a class="type" href="../../../include/x86_64-linux-gnu/bits/time.h.html#timeval" title='timeval' data-ref="timeval">timeval</a> <dfn class="decl" id="Progress::speeder_time" title='Progress::speeder_time' data-ref="Progress::speeder_time">speeder_time</dfn>[ <a class="macro" href="#631" title="(5+1)" data-ref="_M/CURR_TIME">CURR_TIME</a> ];</td></tr>
<tr><th id="635">635</th><td>  <em>int</em> <dfn class="decl" id="Progress::speeder_c" title='Progress::speeder_c' data-ref="Progress::speeder_c">speeder_c</dfn>;</td></tr>
<tr><th id="636">636</th><td>};</td></tr>
<tr><th id="637">637</th><td></td></tr>
<tr><th id="638">638</th><td><b>typedef</b> <b>enum</b> {</td></tr>
<tr><th id="639">639</th><td>  <dfn class="enum" id="HTTPREQ_NONE" title='HTTPREQ_NONE' data-ref="HTTPREQ_NONE">HTTPREQ_NONE</dfn>, <i>/* first in list */</i></td></tr>
<tr><th id="640">640</th><td>  <dfn class="enum" id="HTTPREQ_GET" title='HTTPREQ_GET' data-ref="HTTPREQ_GET">HTTPREQ_GET</dfn>,</td></tr>
<tr><th id="641">641</th><td>  <dfn class="enum" id="HTTPREQ_POST" title='HTTPREQ_POST' data-ref="HTTPREQ_POST">HTTPREQ_POST</dfn>,</td></tr>
<tr><th id="642">642</th><td>  <dfn class="enum" id="HTTPREQ_POST_FORM" title='HTTPREQ_POST_FORM' data-ref="HTTPREQ_POST_FORM">HTTPREQ_POST_FORM</dfn>, <i>/* we make a difference internally */</i></td></tr>
<tr><th id="643">643</th><td>  <dfn class="enum" id="HTTPREQ_PUT" title='HTTPREQ_PUT' data-ref="HTTPREQ_PUT">HTTPREQ_PUT</dfn>,</td></tr>
<tr><th id="644">644</th><td>  <dfn class="enum" id="HTTPREQ_CUSTOM" title='HTTPREQ_CUSTOM' data-ref="HTTPREQ_CUSTOM">HTTPREQ_CUSTOM</dfn>,</td></tr>
<tr><th id="645">645</th><td>  <dfn class="enum" id="HTTPREQ_LAST" title='HTTPREQ_LAST' data-ref="HTTPREQ_LAST">HTTPREQ_LAST</dfn> <i>/* last in list */</i></td></tr>
<tr><th id="646">646</th><td>} <dfn class="typedef" id="Curl_HttpReq" title='Curl_HttpReq' data-type='enum Curl_HttpReq' data-ref="Curl_HttpReq">Curl_HttpReq</dfn>;</td></tr>
<tr><th id="647">647</th><td></td></tr>
<tr><th id="648">648</th><td><i>/*</i></td></tr>
<tr><th id="649">649</th><td><i> * Values that are generated, temporary or calculated internally for a</i></td></tr>
<tr><th id="650">650</th><td><i> * "session handle" must be defined within the 'struct urlstate'.  This struct</i></td></tr>
<tr><th id="651">651</th><td><i> * will be used within the SessionHandle struct. When the 'SessionHandle'</i></td></tr>
<tr><th id="652">652</th><td><i> * struct is cloned, this data MUST NOT be copied.</i></td></tr>
<tr><th id="653">653</th><td><i> *</i></td></tr>
<tr><th id="654">654</th><td><i> * Remember that any "state" information goes globally for the curl handle.</i></td></tr>
<tr><th id="655">655</th><td><i> * Session-data MUST be put in the connectdata struct and here.  */</i></td></tr>
<tr><th id="656">656</th><td><u>#define <dfn class="macro" id="_M/MAX_CURL_USER_LENGTH" data-ref="_M/MAX_CURL_USER_LENGTH">MAX_CURL_USER_LENGTH</dfn> 256</u></td></tr>
<tr><th id="657">657</th><td><u>#define <dfn class="macro" id="_M/MAX_CURL_PASSWORD_LENGTH" data-ref="_M/MAX_CURL_PASSWORD_LENGTH">MAX_CURL_PASSWORD_LENGTH</dfn> 256</u></td></tr>
<tr><th id="658">658</th><td><u>#define <dfn class="macro" id="_M/MAX_CURL_USER_LENGTH_TXT" data-ref="_M/MAX_CURL_USER_LENGTH_TXT">MAX_CURL_USER_LENGTH_TXT</dfn> "255"</u></td></tr>
<tr><th id="659">659</th><td><u>#define <dfn class="macro" id="_M/MAX_CURL_PASSWORD_LENGTH_TXT" data-ref="_M/MAX_CURL_PASSWORD_LENGTH_TXT">MAX_CURL_PASSWORD_LENGTH_TXT</dfn> "255"</u></td></tr>
<tr><th id="660">660</th><td></td></tr>
<tr><th id="661">661</th><td><b>struct</b> <dfn class="type def" id="UrlState" title='UrlState' data-ref="UrlState">UrlState</dfn> {</td></tr>
<tr><th id="662">662</th><td>  <b>enum</b> {</td></tr>
<tr><th id="663">663</th><td>    <dfn class="enum" id="UrlState::Curl_if_none" title='UrlState::Curl_if_none' data-ref="UrlState::Curl_if_none">Curl_if_none</dfn>,</td></tr>
<tr><th id="664">664</th><td>    <dfn class="enum" id="UrlState::Curl_if_easy" title='UrlState::Curl_if_easy' data-ref="UrlState::Curl_if_easy">Curl_if_easy</dfn>,</td></tr>
<tr><th id="665">665</th><td>    <dfn class="enum" id="UrlState::Curl_if_multi" title='UrlState::Curl_if_multi' data-ref="UrlState::Curl_if_multi">Curl_if_multi</dfn></td></tr>
<tr><th id="666">666</th><td>  } <dfn class="decl" id="UrlState::used_interface" title='UrlState::used_interface' data-ref="UrlState::used_interface">used_interface</dfn>;</td></tr>
<tr><th id="667">667</th><td></td></tr>
<tr><th id="668">668</th><td>  <i>/* buffers to store authentication data in, as parsed from input options */</i></td></tr>
<tr><th id="669">669</th><td>  <b>struct</b> <a class="type" href="../../../include/x86_64-linux-gnu/bits/time.h.html#timeval" title='timeval' data-ref="timeval">timeval</a> <dfn class="decl" id="UrlState::keeps_speed" title='UrlState::keeps_speed' data-ref="UrlState::keeps_speed">keeps_speed</dfn>; <i>/* for the progress meter really */</i></td></tr>
<tr><th id="670">670</th><td></td></tr>
<tr><th id="671">671</th><td>  <i>/* 'connects' will be an allocated array with pointers. If the pointer is</i></td></tr>
<tr><th id="672">672</th><td><i>     set, it holds an allocated connection. */</i></td></tr>
<tr><th id="673">673</th><td>  <b>struct</b> <a class="type" href="#connectdata" title='connectdata' data-ref="connectdata">connectdata</a> **<dfn class="decl" id="UrlState::connects" title='UrlState::connects' data-ref="UrlState::connects">connects</dfn>;</td></tr>
<tr><th id="674">674</th><td>  <em>long</em> <dfn class="decl" id="UrlState::numconnects" title='UrlState::numconnects' data-ref="UrlState::numconnects">numconnects</dfn>; <i>/* size of the 'connects' array */</i></td></tr>
<tr><th id="675">675</th><td></td></tr>
<tr><th id="676">676</th><td>  <em>char</em> *<dfn class="decl" id="UrlState::headerbuff" title='UrlState::headerbuff' data-ref="UrlState::headerbuff">headerbuff</dfn>; <i>/* allocated buffer to store headers in */</i></td></tr>
<tr><th id="677">677</th><td>  <em>int</em> <dfn class="decl" id="UrlState::headersize" title='UrlState::headersize' data-ref="UrlState::headersize">headersize</dfn>;   <i>/* size of the allocation */</i></td></tr>
<tr><th id="678">678</th><td></td></tr>
<tr><th id="679">679</th><td>  <em>char</em> <dfn class="decl" id="UrlState::buffer" title='UrlState::buffer' data-ref="UrlState::buffer">buffer</dfn>[<a class="macro" href="#104" title="16384" data-ref="_M/BUFSIZE">BUFSIZE</a>+<var>1</var>]; <i>/* download buffer */</i></td></tr>
<tr><th id="680">680</th><td>  <em>char</em> <dfn class="decl" id="UrlState::uploadbuffer" title='UrlState::uploadbuffer' data-ref="UrlState::uploadbuffer">uploadbuffer</dfn>[<a class="macro" href="#104" title="16384" data-ref="_M/BUFSIZE">BUFSIZE</a>+<var>1</var>]; <i>/* upload buffer */</i></td></tr>
<tr><th id="681">681</th><td>  <em>double</em> <dfn class="decl" id="UrlState::current_speed" title='UrlState::current_speed' data-ref="UrlState::current_speed">current_speed</dfn>;  <i>/* the ProgressShow() funcion sets this */</i></td></tr>
<tr><th id="682">682</th><td></td></tr>
<tr><th id="683">683</th><td>  <a class="typedef" href="setup.h.html#bool" title='bool' data-type='unsigned char' data-ref="bool">bool</a> <dfn class="decl" id="UrlState::this_is_a_follow" title='UrlState::this_is_a_follow' data-ref="UrlState::this_is_a_follow">this_is_a_follow</dfn>; <i>/* this is a followed Location: request */</i></td></tr>
<tr><th id="684">684</th><td></td></tr>
<tr><th id="685">685</th><td>  <em>char</em> *<dfn class="decl" id="UrlState::auth_host" title='UrlState::auth_host' data-ref="UrlState::auth_host">auth_host</dfn>; <i>/* if set, this should be the host name that we will</i></td></tr>
<tr><th id="686">686</th><td><i>                      sent authorization to, no else. Used to make Location:</i></td></tr>
<tr><th id="687">687</th><td><i>                      following not keep sending user+password... This is</i></td></tr>
<tr><th id="688">688</th><td><i>                      strdup() data.</i></td></tr>
<tr><th id="689">689</th><td><i>                    */</i></td></tr>
<tr><th id="690">690</th><td></td></tr>
<tr><th id="691">691</th><td>  <b>struct</b> <a class="type" href="#curl_ssl_session" title='curl_ssl_session' data-ref="curl_ssl_session">curl_ssl_session</a> *<dfn class="decl" id="UrlState::session" title='UrlState::session' data-ref="UrlState::session">session</dfn>; <i>/* array of 'numsessions' size */</i></td></tr>
<tr><th id="692">692</th><td>  <em>long</em> <dfn class="decl" id="UrlState::sessionage" title='UrlState::sessionage' data-ref="UrlState::sessionage">sessionage</dfn>;                  <i>/* number of the most recent session */</i></td></tr>
<tr><th id="693">693</th><td></td></tr>
<tr><th id="694">694</th><td>  <em>char</em> *<dfn class="decl" id="UrlState::scratch" title='UrlState::scratch' data-ref="UrlState::scratch">scratch</dfn>; <i>/* huge buffer[BUFSIZE*2] when doing upload CRLF replacing */</i></td></tr>
<tr><th id="695">695</th><td>  <a class="typedef" href="setup.h.html#bool" title='bool' data-type='unsigned char' data-ref="bool">bool</a> <dfn class="decl" id="UrlState::errorbuf" title='UrlState::errorbuf' data-ref="UrlState::errorbuf">errorbuf</dfn>; <i>/* Set to TRUE if the error buffer is already filled in.</i></td></tr>
<tr><th id="696">696</th><td><i>                    This must be set to FALSE every time _easy_perform() is</i></td></tr>
<tr><th id="697">697</th><td><i>                    called. */</i></td></tr>
<tr><th id="698">698</th><td></td></tr>
<tr><th id="699">699</th><td><u>#<span data-ppcond="699">ifdef</span> <a class="macro" href="config.h.html#275" data-ref="_M/HAVE_SIGNAL">HAVE_SIGNAL</a></u></td></tr>
<tr><th id="700">700</th><td>  <i>/* storage for the previous bag^H^H^HSIGPIPE signal handler :-) */</i></td></tr>
<tr><th id="701">701</th><td>  <em>void</em> (*<dfn class="decl" id="UrlState::prev_signal" title='UrlState::prev_signal' data-ref="UrlState::prev_signal">prev_signal</dfn>)(<em>int</em> <dfn class="local col0 decl" id="540sig" title='sig' data-type='int' data-ref="540sig">sig</dfn>);</td></tr>
<tr><th id="702">702</th><td><u>#<span data-ppcond="699">endif</span></u></td></tr>
<tr><th id="703">703</th><td>  <a class="typedef" href="setup.h.html#bool" title='bool' data-type='unsigned char' data-ref="bool">bool</a> <dfn class="decl" id="UrlState::allow_port" title='UrlState::allow_port' data-ref="UrlState::allow_port">allow_port</dfn>; <i>/* Is set.use_port allowed to take effect or not. This</i></td></tr>
<tr><th id="704">704</th><td><i>                      is always set TRUE when curl_easy_perform() is called. */</i></td></tr>
<tr><th id="705">705</th><td></td></tr>
<tr><th id="706">706</th><td>  <b>struct</b> <a class="type" href="#digestdata" title='digestdata' data-ref="digestdata">digestdata</a> <dfn class="decl" id="UrlState::digest" title='UrlState::digest' data-ref="UrlState::digest">digest</dfn>;</td></tr>
<tr><th id="707">707</th><td></td></tr>
<tr><th id="708">708</th><td><u>#<span data-ppcond="708">ifdef</span> <span class="macro" data-ref="_M/HAVE_GSSAPI">HAVE_GSSAPI</span></u></td></tr>
<tr><th id="709">709</th><td>  <b>struct</b> negotiatedata negotiate;</td></tr>
<tr><th id="710">710</th><td><u>#<span data-ppcond="708">endif</span></u></td></tr>
<tr><th id="711">711</th><td></td></tr>
<tr><th id="712">712</th><td>  <em>long</em> <dfn class="decl" id="UrlState::authstage" title='UrlState::authstage' data-ref="UrlState::authstage">authstage</dfn>; <i>/*   0 - authwant and authavail are still not initialized</i></td></tr>
<tr><th id="713">713</th><td><i>                     401 - web authentication is performed</i></td></tr>
<tr><th id="714">714</th><td><i>                     407 - proxy authentication is performed */</i></td></tr>
<tr><th id="715">715</th><td>  <em>long</em> <dfn class="decl" id="UrlState::authwant" title='UrlState::authwant' data-ref="UrlState::authwant">authwant</dfn>;  <i>/* initially set to authentication methods requested by</i></td></tr>
<tr><th id="716">716</th><td><i>                     client (either with CURLOPT_HTTPAUTH or CURLOPT_PROXYAUTH</i></td></tr>
<tr><th id="717">717</th><td><i>                     depending on authstage) */</i></td></tr>
<tr><th id="718">718</th><td>  <em>long</em> <dfn class="decl" id="UrlState::authavail" title='UrlState::authavail' data-ref="UrlState::authavail">authavail</dfn>; <i>/* what the server reports */</i></td></tr>
<tr><th id="719">719</th><td></td></tr>
<tr><th id="720">720</th><td><u>#<span data-ppcond="720">ifdef</span> <span class="macro" data-ref="_M/USE_ARES">USE_ARES</span></u></td></tr>
<tr><th id="721">721</th><td>  ares_channel areschannel; <i>/* for name resolves */</i></td></tr>
<tr><th id="722">722</th><td><u>#<span data-ppcond="720">endif</span></u></td></tr>
<tr><th id="723">723</th><td>};</td></tr>
<tr><th id="724">724</th><td></td></tr>
<tr><th id="725">725</th><td></td></tr>
<tr><th id="726">726</th><td><i>/*</i></td></tr>
<tr><th id="727">727</th><td><i> * This 'DynamicStatic' struct defines dynamic states that actually change</i></td></tr>
<tr><th id="728">728</th><td><i> * values in the 'UserDefined' area, which MUST be taken into consideration</i></td></tr>
<tr><th id="729">729</th><td><i> * if the UserDefined struct is cloned or similar. You can probably just</i></td></tr>
<tr><th id="730">730</th><td><i> * copy these, but each one indicate a special action on other data.</i></td></tr>
<tr><th id="731">731</th><td><i> */</i></td></tr>
<tr><th id="732">732</th><td></td></tr>
<tr><th id="733">733</th><td><b>struct</b> <dfn class="type def" id="DynamicStatic" title='DynamicStatic' data-ref="DynamicStatic">DynamicStatic</dfn> {</td></tr>
<tr><th id="734">734</th><td>  <em>char</em> *<dfn class="decl" id="DynamicStatic::url" title='DynamicStatic::url' data-ref="DynamicStatic::url">url</dfn>;        <i>/* work URL, copied from UserDefined */</i></td></tr>
<tr><th id="735">735</th><td>  <a class="typedef" href="setup.h.html#bool" title='bool' data-type='unsigned char' data-ref="bool">bool</a> <dfn class="decl" id="DynamicStatic::url_alloc" title='DynamicStatic::url_alloc' data-ref="DynamicStatic::url_alloc">url_alloc</dfn>;   <i>/* URL string is malloc()'ed */</i></td></tr>
<tr><th id="736">736</th><td>  <a class="typedef" href="setup.h.html#bool" title='bool' data-type='unsigned char' data-ref="bool">bool</a> <dfn class="decl" id="DynamicStatic::url_changed" title='DynamicStatic::url_changed' data-ref="DynamicStatic::url_changed">url_changed</dfn>; <i>/* set on CURL_OPT_URL, used to detect if the URL was</i></td></tr>
<tr><th id="737">737</th><td><i>                       changed after the connect phase, as we allow callback</i></td></tr>
<tr><th id="738">738</th><td><i>                       to change it and if so, we reconnect to use the new </i></td></tr>
<tr><th id="739">739</th><td><i>                       URL instead */</i></td></tr>
<tr><th id="740">740</th><td>  <em>char</em> *<dfn class="decl" id="DynamicStatic::proxy" title='DynamicStatic::proxy' data-ref="DynamicStatic::proxy">proxy</dfn>;      <i>/* work proxy, copied from UserDefined */</i></td></tr>
<tr><th id="741">741</th><td>  <a class="typedef" href="setup.h.html#bool" title='bool' data-type='unsigned char' data-ref="bool">bool</a> <dfn class="decl" id="DynamicStatic::proxy_alloc" title='DynamicStatic::proxy_alloc' data-ref="DynamicStatic::proxy_alloc">proxy_alloc</dfn>; <i>/* http proxy string is malloc()'ed */</i></td></tr>
<tr><th id="742">742</th><td>  <em>char</em> *<dfn class="decl" id="DynamicStatic::referer" title='DynamicStatic::referer' data-ref="DynamicStatic::referer">referer</dfn>;    <i>/* referer string */</i></td></tr>
<tr><th id="743">743</th><td>  <a class="typedef" href="setup.h.html#bool" title='bool' data-type='unsigned char' data-ref="bool">bool</a> <dfn class="decl" id="DynamicStatic::referer_alloc" title='DynamicStatic::referer_alloc' data-ref="DynamicStatic::referer_alloc">referer_alloc</dfn>; <i>/* referer sting is malloc()ed */</i></td></tr>
<tr><th id="744">744</th><td>  <b>struct</b> <a class="type" href="../include/curl/curl.h.html#curl_slist" title='curl_slist' data-ref="curl_slist">curl_slist</a> *<dfn class="decl" id="DynamicStatic::cookielist" title='DynamicStatic::cookielist' data-ref="DynamicStatic::cookielist">cookielist</dfn>; <i>/* list of cookie files set by</i></td></tr>
<tr><th id="745">745</th><td><i>                                    curl_easy_setopt(COOKIEFILE) calls */</i></td></tr>
<tr><th id="746">746</th><td>};</td></tr>
<tr><th id="747">747</th><td></td></tr>
<tr><th id="748">748</th><td><i>/*</i></td></tr>
<tr><th id="749">749</th><td><i> * This 'UserDefined' struct must only contain data that is set once to go</i></td></tr>
<tr><th id="750">750</th><td><i> * for many (perhaps) independent connections. Values that are generated or</i></td></tr>
<tr><th id="751">751</th><td><i> * calculated internally for the "session handle" MUST be defined within the</i></td></tr>
<tr><th id="752">752</th><td><i> * 'struct urlstate' instead. The only exceptions MUST note the changes in</i></td></tr>
<tr><th id="753">753</th><td><i> * the 'DynamicStatic' struct.</i></td></tr>
<tr><th id="754">754</th><td><i> */</i></td></tr>
<tr><th id="755">755</th><td></td></tr>
<tr><th id="756">756</th><td><b>struct</b> <dfn class="type def" id="UserDefined" title='UserDefined' data-ref="UserDefined">UserDefined</dfn> {</td></tr>
<tr><th id="757">757</th><td>  <a class="typedef" href="../../../include/stdio.h.html#FILE" title='FILE' data-type='struct _IO_FILE' data-ref="FILE">FILE</a> *<dfn class="decl" id="UserDefined::err" title='UserDefined::err' data-ref="UserDefined::err">err</dfn>;         <i>/* the stderr user data goes here */</i></td></tr>
<tr><th id="758">758</th><td>  <em>void</em> *<dfn class="decl" id="UserDefined::debugdata" title='UserDefined::debugdata' data-ref="UserDefined::debugdata">debugdata</dfn>;   <i>/* the data that will be passed to fdebug */</i></td></tr>
<tr><th id="759">759</th><td>  <em>char</em> *<dfn class="decl" id="UserDefined::errorbuffer" title='UserDefined::errorbuffer' data-ref="UserDefined::errorbuffer">errorbuffer</dfn>; <i>/* store failure messages in here */</i></td></tr>
<tr><th id="760">760</th><td>  <em>char</em> *<dfn class="decl" id="UserDefined::proxyuserpwd" title='UserDefined::proxyuserpwd' data-ref="UserDefined::proxyuserpwd">proxyuserpwd</dfn>;  <i>/* Proxy &lt;user:password&gt;, if used */</i></td></tr>
<tr><th id="761">761</th><td>  <em>long</em> <dfn class="decl" id="UserDefined::proxyport" title='UserDefined::proxyport' data-ref="UserDefined::proxyport">proxyport</dfn>; <i>/* If non-zero, use this port number by default. If the</i></td></tr>
<tr><th id="762">762</th><td><i>                     proxy string features a ":[port]" that one will override</i></td></tr>
<tr><th id="763">763</th><td><i>                     this. */</i>  </td></tr>
<tr><th id="764">764</th><td>  <em>void</em> *<dfn class="decl" id="UserDefined::out" title='UserDefined::out' data-ref="UserDefined::out">out</dfn>;         <i>/* the fetched file goes here */</i></td></tr>
<tr><th id="765">765</th><td>  <em>void</em> *<dfn class="decl" id="UserDefined::in" title='UserDefined::in' data-ref="UserDefined::in">in</dfn>;          <i>/* the uploaded file is read from here */</i></td></tr>
<tr><th id="766">766</th><td>  <em>void</em> *<dfn class="decl" id="UserDefined::writeheader" title='UserDefined::writeheader' data-ref="UserDefined::writeheader">writeheader</dfn>; <i>/* write the header to this is non-NULL */</i></td></tr>
<tr><th id="767">767</th><td>  <em>char</em> *<dfn class="decl" id="UserDefined::set_url" title='UserDefined::set_url' data-ref="UserDefined::set_url">set_url</dfn>;     <i>/* what original URL to work on */</i></td></tr>
<tr><th id="768">768</th><td>  <em>char</em> *<dfn class="decl" id="UserDefined::set_proxy" title='UserDefined::set_proxy' data-ref="UserDefined::set_proxy">set_proxy</dfn>;   <i>/* proxy to use */</i></td></tr>
<tr><th id="769">769</th><td>  <em>long</em> <dfn class="decl" id="UserDefined::use_port" title='UserDefined::use_port' data-ref="UserDefined::use_port">use_port</dfn>;     <i>/* which port to use (when not using default) */</i></td></tr>
<tr><th id="770">770</th><td>  <em>char</em> *<dfn class="decl" id="UserDefined::userpwd" title='UserDefined::userpwd' data-ref="UserDefined::userpwd">userpwd</dfn>;     <i>/* &lt;user:password&gt;, if used */</i></td></tr>
<tr><th id="771">771</th><td>  <em>long</em> <dfn class="decl" id="UserDefined::httpauth" title='UserDefined::httpauth' data-ref="UserDefined::httpauth">httpauth</dfn>;     <i>/* what kind of HTTP authentication to use (bitmask) */</i></td></tr>
<tr><th id="772">772</th><td>  <em>long</em> <dfn class="decl" id="UserDefined::proxyauth" title='UserDefined::proxyauth' data-ref="UserDefined::proxyauth">proxyauth</dfn>;    <i>/* what kind of proxy authentication to use (bitmask) */</i></td></tr>
<tr><th id="773">773</th><td>  <em>char</em> *<dfn class="decl" id="UserDefined::set_range" title='UserDefined::set_range' data-ref="UserDefined::set_range">set_range</dfn>;   <i>/* range, if used. See README for detailed specification</i></td></tr>
<tr><th id="774">774</th><td><i>                        on this syntax. */</i></td></tr>
<tr><th id="775">775</th><td>  <em>long</em> <dfn class="decl" id="UserDefined::followlocation" title='UserDefined::followlocation' data-ref="UserDefined::followlocation">followlocation</dfn>; <i>/* as in HTTP Location: */</i></td></tr>
<tr><th id="776">776</th><td>  <em>long</em> <dfn class="decl" id="UserDefined::maxredirs" title='UserDefined::maxredirs' data-ref="UserDefined::maxredirs">maxredirs</dfn>;    <i>/* maximum no. of http(s) redirects to follow */</i></td></tr>
<tr><th id="777">777</th><td>  <em>char</em> *<dfn class="decl" id="UserDefined::set_referer" title='UserDefined::set_referer' data-ref="UserDefined::set_referer">set_referer</dfn>; <i>/* custom string */</i></td></tr>
<tr><th id="778">778</th><td>  <a class="typedef" href="setup.h.html#bool" title='bool' data-type='unsigned char' data-ref="bool">bool</a> <dfn class="decl" id="UserDefined::free_referer" title='UserDefined::free_referer' data-ref="UserDefined::free_referer">free_referer</dfn>; <i>/* set TRUE if 'referer' points to a string we</i></td></tr>
<tr><th id="779">779</th><td><i>                        allocated */</i></td></tr>
<tr><th id="780">780</th><td>  <em>char</em> *<dfn class="decl" id="UserDefined::useragent" title='UserDefined::useragent' data-ref="UserDefined::useragent">useragent</dfn>;   <i>/* User-Agent string */</i></td></tr>
<tr><th id="781">781</th><td>  <em>char</em> *<dfn class="decl" id="UserDefined::encoding" title='UserDefined::encoding' data-ref="UserDefined::encoding">encoding</dfn>;    <i>/* Accept-Encoding string */</i></td></tr>
<tr><th id="782">782</th><td>  <em>char</em> *<dfn class="decl" id="UserDefined::postfields" title='UserDefined::postfields' data-ref="UserDefined::postfields">postfields</dfn>;  <i>/* if POST, set the fields' values here */</i></td></tr>
<tr><th id="783">783</th><td>  <a class="typedef" href="../include/curl/curl.h.html#curl_off_t" title='curl_off_t' data-type='off_t' data-ref="curl_off_t">curl_off_t</a> <dfn class="decl" id="UserDefined::postfieldsize" title='UserDefined::postfieldsize' data-ref="UserDefined::postfieldsize">postfieldsize</dfn>; <i>/* if POST, this might have a size to use instead</i></td></tr>
<tr><th id="784">784</th><td><i>                               of strlen(), and then the data *may* be binary</i></td></tr>
<tr><th id="785">785</th><td><i>                               (contain zero bytes) */</i></td></tr>
<tr><th id="786">786</th><td>  <em>char</em> *<dfn class="decl" id="UserDefined::ftpport" title='UserDefined::ftpport' data-ref="UserDefined::ftpport">ftpport</dfn>;     <i>/* port to send with the FTP PORT command */</i></td></tr>
<tr><th id="787">787</th><td>  <em>char</em> *<dfn class="decl" id="UserDefined::device" title='UserDefined::device' data-ref="UserDefined::device">device</dfn>;      <i>/* network interface to use */</i></td></tr>
<tr><th id="788">788</th><td>  <a class="typedef" href="../include/curl/curl.h.html#curl_write_callback" title='curl_write_callback' data-type='size_t (*)(char *, size_t, size_t, void *)' data-ref="curl_write_callback">curl_write_callback</a> <dfn class="decl" id="UserDefined::fwrite" title='UserDefined::fwrite' data-ref="UserDefined::fwrite">fwrite</dfn>;        <i>/* function that stores the output */</i></td></tr>
<tr><th id="789">789</th><td>  <a class="typedef" href="../include/curl/curl.h.html#curl_write_callback" title='curl_write_callback' data-type='size_t (*)(char *, size_t, size_t, void *)' data-ref="curl_write_callback">curl_write_callback</a> <dfn class="decl" id="UserDefined::fwrite_header" title='UserDefined::fwrite_header' data-ref="UserDefined::fwrite_header">fwrite_header</dfn>; <i>/* function that stores headers */</i></td></tr>
<tr><th id="790">790</th><td>  <a class="typedef" href="../include/curl/curl.h.html#curl_read_callback" title='curl_read_callback' data-type='size_t (*)(char *, size_t, size_t, void *)' data-ref="curl_read_callback">curl_read_callback</a> <dfn class="decl" id="UserDefined::fread" title='UserDefined::fread' data-ref="UserDefined::fread">fread</dfn>;          <i>/* function that reads the input */</i></td></tr>
<tr><th id="791">791</th><td>  <a class="typedef" href="../include/curl/curl.h.html#curl_progress_callback" title='curl_progress_callback' data-type='int (*)(void *, double, double, double, double)' data-ref="curl_progress_callback">curl_progress_callback</a> <dfn class="decl" id="UserDefined::fprogress" title='UserDefined::fprogress' data-ref="UserDefined::fprogress">fprogress</dfn>;  <i>/* function for progress information */</i></td></tr>
<tr><th id="792">792</th><td>  <a class="typedef" href="../include/curl/curl.h.html#curl_debug_callback" title='curl_debug_callback' data-type='int (*)(CURL *, curl_infotype, char *, size_t, void *)' data-ref="curl_debug_callback">curl_debug_callback</a> <dfn class="decl" id="UserDefined::fdebug" title='UserDefined::fdebug' data-ref="UserDefined::fdebug">fdebug</dfn>;      <i>/* function that write informational data */</i></td></tr>
<tr><th id="793">793</th><td>  <em>void</em> *<dfn class="decl" id="UserDefined::progress_client" title='UserDefined::progress_client' data-ref="UserDefined::progress_client">progress_client</dfn>; <i>/* pointer to pass to the progress callback */</i></td></tr>
<tr><th id="794">794</th><td>  <em>long</em> <dfn class="decl" id="UserDefined::timeout" title='UserDefined::timeout' data-ref="UserDefined::timeout">timeout</dfn>;         <i>/* in seconds, 0 means no timeout */</i></td></tr>
<tr><th id="795">795</th><td>  <em>long</em> <dfn class="decl" id="UserDefined::connecttimeout" title='UserDefined::connecttimeout' data-ref="UserDefined::connecttimeout">connecttimeout</dfn>;  <i>/* in seconds, 0 means no timeout */</i></td></tr>
<tr><th id="796">796</th><td>  <em>long</em> <dfn class="decl" id="UserDefined::ftp_response_timeout" title='UserDefined::ftp_response_timeout' data-ref="UserDefined::ftp_response_timeout">ftp_response_timeout</dfn>; <i>/* in seconds, 0 means no timeout */</i></td></tr>
<tr><th id="797">797</th><td>  <a class="typedef" href="../include/curl/curl.h.html#curl_off_t" title='curl_off_t' data-type='off_t' data-ref="curl_off_t">curl_off_t</a> <dfn class="decl" id="UserDefined::infilesize" title='UserDefined::infilesize' data-ref="UserDefined::infilesize">infilesize</dfn>;      <i>/* size of file to upload, -1 means unknown */</i></td></tr>
<tr><th id="798">798</th><td>  <em>long</em> <dfn class="decl" id="UserDefined::low_speed_limit" title='UserDefined::low_speed_limit' data-ref="UserDefined::low_speed_limit">low_speed_limit</dfn>; <i>/* bytes/second */</i></td></tr>
<tr><th id="799">799</th><td>  <em>long</em> <dfn class="decl" id="UserDefined::low_speed_time" title='UserDefined::low_speed_time' data-ref="UserDefined::low_speed_time">low_speed_time</dfn>;  <i>/* number of seconds */</i></td></tr>
<tr><th id="800">800</th><td>  <a class="typedef" href="../include/curl/curl.h.html#curl_off_t" title='curl_off_t' data-type='off_t' data-ref="curl_off_t">curl_off_t</a> <dfn class="decl" id="UserDefined::set_resume_from" title='UserDefined::set_resume_from' data-ref="UserDefined::set_resume_from">set_resume_from</dfn>;  <i>/* continue [ftp] transfer from here */</i></td></tr>
<tr><th id="801">801</th><td>  <em>char</em> *<dfn class="decl" id="UserDefined::cookie" title='UserDefined::cookie' data-ref="UserDefined::cookie">cookie</dfn>;         <i>/* HTTP cookie string to send */</i></td></tr>
<tr><th id="802">802</th><td>  <b>struct</b> <a class="type" href="../include/curl/curl.h.html#curl_slist" title='curl_slist' data-ref="curl_slist">curl_slist</a> *<dfn class="decl" id="UserDefined::headers" title='UserDefined::headers' data-ref="UserDefined::headers">headers</dfn>; <i>/* linked list of extra headers */</i></td></tr>
<tr><th id="803">803</th><td>  <b>struct</b> <a class="type" href="../include/curl/curl.h.html#curl_httppost" title='curl_httppost' data-ref="curl_httppost">curl_httppost</a> *<dfn class="decl" id="UserDefined::httppost" title='UserDefined::httppost' data-ref="UserDefined::httppost">httppost</dfn>;  <i>/* linked list of POST data */</i></td></tr>
<tr><th id="804">804</th><td>  <em>char</em> *<dfn class="decl" id="UserDefined::cert" title='UserDefined::cert' data-ref="UserDefined::cert">cert</dfn>;           <i>/* certificate */</i></td></tr>
<tr><th id="805">805</th><td>  <em>char</em> *<dfn class="decl" id="UserDefined::cert_type" title='UserDefined::cert_type' data-ref="UserDefined::cert_type">cert_type</dfn>;      <i>/* format for certificate (default: PEM) */</i></td></tr>
<tr><th id="806">806</th><td>  <em>char</em> *<dfn class="decl" id="UserDefined::key" title='UserDefined::key' data-ref="UserDefined::key">key</dfn>;            <i>/* private key */</i></td></tr>
<tr><th id="807">807</th><td>  <em>char</em> *<dfn class="decl" id="UserDefined::key_type" title='UserDefined::key_type' data-ref="UserDefined::key_type">key_type</dfn>;       <i>/* format for private key (default: PEM) */</i></td></tr>
<tr><th id="808">808</th><td>  <em>char</em> *<dfn class="decl" id="UserDefined::key_passwd" title='UserDefined::key_passwd' data-ref="UserDefined::key_passwd">key_passwd</dfn>;     <i>/* plain text private key password */</i></td></tr>
<tr><th id="809">809</th><td>  <em>char</em> *<dfn class="decl" id="UserDefined::crypto_engine" title='UserDefined::crypto_engine' data-ref="UserDefined::crypto_engine">crypto_engine</dfn>;  <i>/* name of the crypto engine to use */</i></td></tr>
<tr><th id="810">810</th><td>  <em>char</em> *<dfn class="decl" id="UserDefined::cookiejar" title='UserDefined::cookiejar' data-ref="UserDefined::cookiejar">cookiejar</dfn>;      <i>/* dump all cookies to this file */</i></td></tr>
<tr><th id="811">811</th><td>  <a class="typedef" href="setup.h.html#bool" title='bool' data-type='unsigned char' data-ref="bool">bool</a> <dfn class="decl" id="UserDefined::cookiesession" title='UserDefined::cookiesession' data-ref="UserDefined::cookiesession">cookiesession</dfn>;   <i>/* new cookie session? */</i></td></tr>
<tr><th id="812">812</th><td>  <a class="typedef" href="setup.h.html#bool" title='bool' data-type='unsigned char' data-ref="bool">bool</a> <dfn class="decl" id="UserDefined::crlf" title='UserDefined::crlf' data-ref="UserDefined::crlf">crlf</dfn>;            <i>/* convert crlf on ftp upload(?) */</i></td></tr>
<tr><th id="813">813</th><td>  <b>struct</b> <a class="type" href="../include/curl/curl.h.html#curl_slist" title='curl_slist' data-ref="curl_slist">curl_slist</a> *<dfn class="decl" id="UserDefined::quote" title='UserDefined::quote' data-ref="UserDefined::quote">quote</dfn>;     <i>/* after connection is established */</i></td></tr>
<tr><th id="814">814</th><td>  <b>struct</b> <a class="type" href="../include/curl/curl.h.html#curl_slist" title='curl_slist' data-ref="curl_slist">curl_slist</a> *<dfn class="decl" id="UserDefined::postquote" title='UserDefined::postquote' data-ref="UserDefined::postquote">postquote</dfn>; <i>/* after the transfer */</i></td></tr>
<tr><th id="815">815</th><td>  <b>struct</b> <a class="type" href="../include/curl/curl.h.html#curl_slist" title='curl_slist' data-ref="curl_slist">curl_slist</a> *<dfn class="decl" id="UserDefined::prequote" title='UserDefined::prequote' data-ref="UserDefined::prequote">prequote</dfn>; <i>/* before the transfer, after type (Wesley Laxton)*/</i></td></tr>
<tr><th id="816">816</th><td>  <b>struct</b> <a class="type" href="../include/curl/curl.h.html#curl_slist" title='curl_slist' data-ref="curl_slist">curl_slist</a> *<dfn class="decl" id="UserDefined::telnet_options" title='UserDefined::telnet_options' data-ref="UserDefined::telnet_options">telnet_options</dfn>; <i>/* linked list of telnet options */</i></td></tr>
<tr><th id="817">817</th><td>  <a class="typedef" href="../include/curl/curl.h.html#curl_TimeCond" title='curl_TimeCond' data-type='enum curl_TimeCond' data-ref="curl_TimeCond">curl_TimeCond</a> <dfn class="decl" id="UserDefined::timecondition" title='UserDefined::timecondition' data-ref="UserDefined::timecondition">timecondition</dfn>; <i>/* kind of time/date comparison */</i></td></tr>
<tr><th id="818">818</th><td>  <a class="typedef" href="../../../include/time.h.html#time_t" title='time_t' data-type='__time_t' data-ref="time_t">time_t</a> <dfn class="decl" id="UserDefined::timevalue" title='UserDefined::timevalue' data-ref="UserDefined::timevalue">timevalue</dfn>;       <i>/* what time to compare with */</i></td></tr>
<tr><th id="819">819</th><td>  <a class="typedef" href="../include/curl/curl.h.html#curl_closepolicy" title='curl_closepolicy' data-type='enum curl_closepolicy' data-ref="curl_closepolicy">curl_closepolicy</a> <dfn class="decl" id="UserDefined::closepolicy" title='UserDefined::closepolicy' data-ref="UserDefined::closepolicy">closepolicy</dfn>; <i>/* connection cache close concept */</i></td></tr>
<tr><th id="820">820</th><td>  <a class="typedef" href="#Curl_HttpReq" title='Curl_HttpReq' data-type='enum Curl_HttpReq' data-ref="Curl_HttpReq">Curl_HttpReq</a> <dfn class="decl" id="UserDefined::httpreq" title='UserDefined::httpreq' data-ref="UserDefined::httpreq">httpreq</dfn>;   <i>/* what kind of HTTP request (if any) is this */</i></td></tr>
<tr><th id="821">821</th><td>  <em>char</em> *<dfn class="decl" id="UserDefined::customrequest" title='UserDefined::customrequest' data-ref="UserDefined::customrequest">customrequest</dfn>;    <i>/* HTTP/FTP request to use */</i></td></tr>
<tr><th id="822">822</th><td>  <em>long</em> <dfn class="decl" id="UserDefined::httpversion" title='UserDefined::httpversion' data-ref="UserDefined::httpversion">httpversion</dfn>; <i>/* when non-zero, a specific HTTP version requested to</i></td></tr>
<tr><th id="823">823</th><td><i>                       be used in the library's request(s) */</i></td></tr>
<tr><th id="824">824</th><td>  <em>char</em> *<dfn class="decl" id="UserDefined::auth_host" title='UserDefined::auth_host' data-ref="UserDefined::auth_host">auth_host</dfn>; <i>/* if set, this is the allocated string to the host name</i></td></tr>
<tr><th id="825">825</th><td><i>                    * to which to send the authorization data to, and no other</i></td></tr>
<tr><th id="826">826</th><td><i>                    * host (which location-following otherwise could lead to)</i></td></tr>
<tr><th id="827">827</th><td><i>                    */</i></td></tr>
<tr><th id="828">828</th><td>  <em>char</em> *<dfn class="decl" id="UserDefined::krb4_level" title='UserDefined::krb4_level' data-ref="UserDefined::krb4_level">krb4_level</dfn>; <i>/* what security level */</i></td></tr>
<tr><th id="829">829</th><td>  <b>struct</b> <a class="type" href="#ssl_config_data" title='ssl_config_data' data-ref="ssl_config_data">ssl_config_data</a> <dfn class="decl" id="UserDefined::ssl" title='UserDefined::ssl' data-ref="UserDefined::ssl">ssl</dfn>;  <i>/* user defined SSL stuff */</i></td></tr>
<tr><th id="830">830</th><td></td></tr>
<tr><th id="831">831</th><td>  <a class="typedef" href="../include/curl/curl.h.html#curl_proxytype" title='curl_proxytype' data-type='enum curl_proxytype' data-ref="curl_proxytype">curl_proxytype</a> <dfn class="decl" id="UserDefined::proxytype" title='UserDefined::proxytype' data-ref="UserDefined::proxytype">proxytype</dfn>; <i>/* what kind of proxy that is in use */</i></td></tr>
<tr><th id="832">832</th><td></td></tr>
<tr><th id="833">833</th><td>  <em>int</em> <dfn class="decl" id="UserDefined::dns_cache_timeout" title='UserDefined::dns_cache_timeout' data-ref="UserDefined::dns_cache_timeout">dns_cache_timeout</dfn>; <i>/* DNS cache timeout */</i></td></tr>
<tr><th id="834">834</th><td>  <em>long</em> <dfn class="decl" id="UserDefined::buffer_size" title='UserDefined::buffer_size' data-ref="UserDefined::buffer_size">buffer_size</dfn>;      <i>/* size of receive buffer to use */</i></td></tr>
<tr><th id="835">835</th><td></td></tr>
<tr><th id="836">836</th><td>  <em>char</em> *<dfn class="decl" id="UserDefined::private" title='UserDefined::private' data-ref="UserDefined::private">private</dfn>; <i>/* Private data */</i></td></tr>
<tr><th id="837">837</th><td></td></tr>
<tr><th id="838">838</th><td>  <b>struct</b> <a class="type" href="../include/curl/curl.h.html#curl_slist" title='curl_slist' data-ref="curl_slist">curl_slist</a> *<dfn class="decl" id="UserDefined::http200aliases" title='UserDefined::http200aliases' data-ref="UserDefined::http200aliases">http200aliases</dfn>; <i>/* linked list of aliases for http200 */</i></td></tr>
<tr><th id="839">839</th><td></td></tr>
<tr><th id="840">840</th><td>  <em>int</em> <dfn class="decl" id="UserDefined::ip_version" title='UserDefined::ip_version' data-ref="UserDefined::ip_version">ip_version</dfn>; </td></tr>
<tr><th id="841">841</th><td></td></tr>
<tr><th id="842">842</th><td>  <a class="typedef" href="../include/curl/curl.h.html#curl_off_t" title='curl_off_t' data-type='off_t' data-ref="curl_off_t">curl_off_t</a> <dfn class="decl" id="UserDefined::max_filesize" title='UserDefined::max_filesize' data-ref="UserDefined::max_filesize">max_filesize</dfn>; <i>/* Maximum file size to download */</i></td></tr>
<tr><th id="843">843</th><td>  </td></tr>
<tr><th id="844">844</th><td><i>/* Here follows boolean settings that define how to behave during</i></td></tr>
<tr><th id="845">845</th><td><i>   this session. They are STATIC, set by libcurl users or at least initially</i></td></tr>
<tr><th id="846">846</th><td><i>   and they don't change during operations. */</i></td></tr>
<tr><th id="847">847</th><td></td></tr>
<tr><th id="848">848</th><td>  <a class="typedef" href="setup.h.html#bool" title='bool' data-type='unsigned char' data-ref="bool">bool</a> <dfn class="decl" id="UserDefined::get_filetime" title='UserDefined::get_filetime' data-ref="UserDefined::get_filetime">get_filetime</dfn>;</td></tr>
<tr><th id="849">849</th><td>  <a class="typedef" href="setup.h.html#bool" title='bool' data-type='unsigned char' data-ref="bool">bool</a> <dfn class="decl" id="UserDefined::tunnel_thru_httpproxy" title='UserDefined::tunnel_thru_httpproxy' data-ref="UserDefined::tunnel_thru_httpproxy">tunnel_thru_httpproxy</dfn>;</td></tr>
<tr><th id="850">850</th><td>  <a class="typedef" href="setup.h.html#bool" title='bool' data-type='unsigned char' data-ref="bool">bool</a> <dfn class="decl" id="UserDefined::ftp_append" title='UserDefined::ftp_append' data-ref="UserDefined::ftp_append">ftp_append</dfn>;</td></tr>
<tr><th id="851">851</th><td>  <a class="typedef" href="setup.h.html#bool" title='bool' data-type='unsigned char' data-ref="bool">bool</a> <dfn class="decl" id="UserDefined::ftp_ascii" title='UserDefined::ftp_ascii' data-ref="UserDefined::ftp_ascii">ftp_ascii</dfn>;</td></tr>
<tr><th id="852">852</th><td>  <a class="typedef" href="setup.h.html#bool" title='bool' data-type='unsigned char' data-ref="bool">bool</a> <dfn class="decl" id="UserDefined::ftp_list_only" title='UserDefined::ftp_list_only' data-ref="UserDefined::ftp_list_only">ftp_list_only</dfn>;</td></tr>
<tr><th id="853">853</th><td>  <a class="typedef" href="setup.h.html#bool" title='bool' data-type='unsigned char' data-ref="bool">bool</a> <dfn class="decl" id="UserDefined::ftp_create_missing_dirs" title='UserDefined::ftp_create_missing_dirs' data-ref="UserDefined::ftp_create_missing_dirs">ftp_create_missing_dirs</dfn>;</td></tr>
<tr><th id="854">854</th><td>  <a class="typedef" href="setup.h.html#bool" title='bool' data-type='unsigned char' data-ref="bool">bool</a> <dfn class="decl" id="UserDefined::ftp_use_port" title='UserDefined::ftp_use_port' data-ref="UserDefined::ftp_use_port">ftp_use_port</dfn>;</td></tr>
<tr><th id="855">855</th><td>  <a class="typedef" href="setup.h.html#bool" title='bool' data-type='unsigned char' data-ref="bool">bool</a> <dfn class="decl" id="UserDefined::hide_progress" title='UserDefined::hide_progress' data-ref="UserDefined::hide_progress">hide_progress</dfn>;</td></tr>
<tr><th id="856">856</th><td>  <a class="typedef" href="setup.h.html#bool" title='bool' data-type='unsigned char' data-ref="bool">bool</a> <dfn class="decl" id="UserDefined::http_fail_on_error" title='UserDefined::http_fail_on_error' data-ref="UserDefined::http_fail_on_error">http_fail_on_error</dfn>;</td></tr>
<tr><th id="857">857</th><td>  <a class="typedef" href="setup.h.html#bool" title='bool' data-type='unsigned char' data-ref="bool">bool</a> <dfn class="decl" id="UserDefined::http_follow_location" title='UserDefined::http_follow_location' data-ref="UserDefined::http_follow_location">http_follow_location</dfn>;</td></tr>
<tr><th id="858">858</th><td>  <a class="typedef" href="setup.h.html#bool" title='bool' data-type='unsigned char' data-ref="bool">bool</a> <dfn class="decl" id="UserDefined::http_disable_hostname_check_before_authentication" title='UserDefined::http_disable_hostname_check_before_authentication' data-ref="UserDefined::http_disable_hostname_check_before_authentication">http_disable_hostname_check_before_authentication</dfn>;</td></tr>
<tr><th id="859">859</th><td>  <a class="typedef" href="setup.h.html#bool" title='bool' data-type='unsigned char' data-ref="bool">bool</a> <dfn class="decl" id="UserDefined::include_header" title='UserDefined::include_header' data-ref="UserDefined::include_header">include_header</dfn>;</td></tr>
<tr><th id="860">860</th><td><u>#define <dfn class="macro" id="_M/http_include_header" data-ref="_M/http_include_header">http_include_header</dfn> include_header /* former name */</u></td></tr>
<tr><th id="861">861</th><td></td></tr>
<tr><th id="862">862</th><td>  <a class="typedef" href="setup.h.html#bool" title='bool' data-type='unsigned char' data-ref="bool">bool</a> <dfn class="decl" id="UserDefined::http_set_referer" title='UserDefined::http_set_referer' data-ref="UserDefined::http_set_referer">http_set_referer</dfn>;</td></tr>
<tr><th id="863">863</th><td>  <a class="typedef" href="setup.h.html#bool" title='bool' data-type='unsigned char' data-ref="bool">bool</a> <dfn class="decl" id="UserDefined::http_auto_referer" title='UserDefined::http_auto_referer' data-ref="UserDefined::http_auto_referer">http_auto_referer</dfn>; <i>/* set "correct" referer when following location: */</i></td></tr>
<tr><th id="864">864</th><td>  <a class="typedef" href="setup.h.html#bool" title='bool' data-type='unsigned char' data-ref="bool">bool</a> <dfn class="decl" id="UserDefined::no_body" title='UserDefined::no_body' data-ref="UserDefined::no_body">no_body</dfn>;</td></tr>
<tr><th id="865">865</th><td>  <a class="typedef" href="setup.h.html#bool" title='bool' data-type='unsigned char' data-ref="bool">bool</a> <dfn class="decl" id="UserDefined::set_port" title='UserDefined::set_port' data-ref="UserDefined::set_port">set_port</dfn>;</td></tr>
<tr><th id="866">866</th><td>  <a class="typedef" href="setup.h.html#bool" title='bool' data-type='unsigned char' data-ref="bool">bool</a> <dfn class="decl" id="UserDefined::upload" title='UserDefined::upload' data-ref="UserDefined::upload">upload</dfn>;</td></tr>
<tr><th id="867">867</th><td>  <b>enum</b> <a class="type" href="../include/curl/curl.h.html#CURL_NETRC_OPTION" title='CURL_NETRC_OPTION' data-ref="CURL_NETRC_OPTION">CURL_NETRC_OPTION</a></td></tr>
<tr><th id="868">868</th><td>       <dfn class="decl" id="UserDefined::use_netrc" title='UserDefined::use_netrc' data-ref="UserDefined::use_netrc">use_netrc</dfn>;        <i>/* defined in include/curl.h */</i></td></tr>
<tr><th id="869">869</th><td>  <em>char</em> *<dfn class="decl" id="UserDefined::netrc_file" title='UserDefined::netrc_file' data-ref="UserDefined::netrc_file">netrc_file</dfn>;      <i>/* if not NULL, use this instead of trying to find</i></td></tr>
<tr><th id="870">870</th><td><i>                            $HOME/.netrc */</i></td></tr>
<tr><th id="871">871</th><td>  <a class="typedef" href="setup.h.html#bool" title='bool' data-type='unsigned char' data-ref="bool">bool</a> <dfn class="decl" id="UserDefined::verbose" title='UserDefined::verbose' data-ref="UserDefined::verbose">verbose</dfn>;</td></tr>
<tr><th id="872">872</th><td>  <a class="typedef" href="setup.h.html#bool" title='bool' data-type='unsigned char' data-ref="bool">bool</a> <dfn class="decl" id="UserDefined::krb4" title='UserDefined::krb4' data-ref="UserDefined::krb4">krb4</dfn>;             <i>/* kerberos4 connection requested */</i></td></tr>
<tr><th id="873">873</th><td>  <a class="typedef" href="setup.h.html#bool" title='bool' data-type='unsigned char' data-ref="bool">bool</a> <dfn class="decl" id="UserDefined::reuse_forbid" title='UserDefined::reuse_forbid' data-ref="UserDefined::reuse_forbid">reuse_forbid</dfn>;     <i>/* forbidden to be reused, close after use */</i></td></tr>
<tr><th id="874">874</th><td>  <a class="typedef" href="setup.h.html#bool" title='bool' data-type='unsigned char' data-ref="bool">bool</a> <dfn class="decl" id="UserDefined::reuse_fresh" title='UserDefined::reuse_fresh' data-ref="UserDefined::reuse_fresh">reuse_fresh</dfn>;      <i>/* do not re-use an existing connection  */</i></td></tr>
<tr><th id="875">875</th><td>  <a class="typedef" href="setup.h.html#bool" title='bool' data-type='unsigned char' data-ref="bool">bool</a> <dfn class="decl" id="UserDefined::expect100header" title='UserDefined::expect100header' data-ref="UserDefined::expect100header">expect100header</dfn>;  <i>/* TRUE if we added Expect: 100-continue */</i></td></tr>
<tr><th id="876">876</th><td>  <a class="typedef" href="setup.h.html#bool" title='bool' data-type='unsigned char' data-ref="bool">bool</a> <dfn class="decl" id="UserDefined::ftp_use_epsv" title='UserDefined::ftp_use_epsv' data-ref="UserDefined::ftp_use_epsv">ftp_use_epsv</dfn>;     <i>/* if EPSV is to be attempted or not */</i></td></tr>
<tr><th id="877">877</th><td>  <a class="typedef" href="setup.h.html#bool" title='bool' data-type='unsigned char' data-ref="bool">bool</a> <dfn class="decl" id="UserDefined::ftp_use_eprt" title='UserDefined::ftp_use_eprt' data-ref="UserDefined::ftp_use_eprt">ftp_use_eprt</dfn>;     <i>/* if EPRT is to be attempted or not */</i></td></tr>
<tr><th id="878">878</th><td>  <a class="typedef" href="../include/curl/curl.h.html#curl_ftpssl" title='curl_ftpssl' data-type='enum curl_ftpssl' data-ref="curl_ftpssl">curl_ftpssl</a> <dfn class="decl" id="UserDefined::ftp_ssl" title='UserDefined::ftp_ssl' data-ref="UserDefined::ftp_ssl">ftp_ssl</dfn>;   <i>/* if AUTH TLS is to be attempted etc */</i></td></tr>
<tr><th id="879">879</th><td>  <a class="typedef" href="setup.h.html#bool" title='bool' data-type='unsigned char' data-ref="bool">bool</a> <dfn class="decl" id="UserDefined::no_signal" title='UserDefined::no_signal' data-ref="UserDefined::no_signal">no_signal</dfn>;        <i>/* do not use any signal/alarm handler */</i></td></tr>
<tr><th id="880">880</th><td></td></tr>
<tr><th id="881">881</th><td>  <a class="typedef" href="setup.h.html#bool" title='bool' data-type='unsigned char' data-ref="bool">bool</a> <dfn class="decl" id="UserDefined::global_dns_cache" title='UserDefined::global_dns_cache' data-ref="UserDefined::global_dns_cache">global_dns_cache</dfn>;</td></tr>
<tr><th id="882">882</th><td>};</td></tr>
<tr><th id="883">883</th><td></td></tr>
<tr><th id="884">884</th><td><i>/*</i></td></tr>
<tr><th id="885">885</th><td><i> * In August 2001, this struct was redesigned and is since stricter than</i></td></tr>
<tr><th id="886">886</th><td><i> * before. The 'connectdata' struct MUST have all the connection oriented</i></td></tr>
<tr><th id="887">887</th><td><i> * stuff as we may now have several simultaneous connections and connection</i></td></tr>
<tr><th id="888">888</th><td><i> * structs in memory.</i></td></tr>
<tr><th id="889">889</th><td><i> *</i></td></tr>
<tr><th id="890">890</th><td><i> * From now on, the 'SessionHandle' must only contain data that is set once to</i></td></tr>
<tr><th id="891">891</th><td><i> * go for many (perhaps) independent connections. Values that are generated or</i></td></tr>
<tr><th id="892">892</th><td><i> * calculated internally for the "session handle" must be defined within the</i></td></tr>
<tr><th id="893">893</th><td><i> * 'struct urlstate' instead.  */</i></td></tr>
<tr><th id="894">894</th><td></td></tr>
<tr><th id="895">895</th><td><b>struct</b> <dfn class="type def" id="SessionHandle" title='SessionHandle' data-ref="SessionHandle">SessionHandle</dfn> {</td></tr>
<tr><th id="896">896</th><td>  <a class="typedef" href="hash.h.html#curl_hash" title='curl_hash' data-type='struct _curl_hash' data-ref="curl_hash">curl_hash</a> *<dfn class="decl" id="SessionHandle::hostcache" title='SessionHandle::hostcache' data-ref="SessionHandle::hostcache">hostcache</dfn>;</td></tr>
<tr><th id="897">897</th><td>  <b>struct</b> <dfn class="type" id="Curl_share" title='Curl_share' data-ref="Curl_share"><a class="type" href="#Curl_share" title='Curl_share' data-ref="Curl_share">Curl_share</a></dfn> *<dfn class="decl" id="SessionHandle::share" title='SessionHandle::share' data-ref="SessionHandle::share">share</dfn>;    <i>/* Share, handles global variable mutexing */</i></td></tr>
<tr><th id="898">898</th><td>  <b>struct</b> <a class="type" href="#UserDefined" title='UserDefined' data-ref="UserDefined">UserDefined</a> <dfn class="decl" id="SessionHandle::set" title='SessionHandle::set' data-ref="SessionHandle::set">set</dfn>;      <i>/* values set by the libcurl user */</i></td></tr>
<tr><th id="899">899</th><td>  <b>struct</b> <a class="type" href="#DynamicStatic" title='DynamicStatic' data-ref="DynamicStatic">DynamicStatic</a> <dfn class="decl" id="SessionHandle::change" title='SessionHandle::change' data-ref="SessionHandle::change">change</dfn>; <i>/* possibly modified userdefined data */</i></td></tr>
<tr><th id="900">900</th><td></td></tr>
<tr><th id="901">901</th><td>  <b>struct</b> <a class="type" href="cookie.h.html#CookieInfo" title='CookieInfo' data-ref="CookieInfo">CookieInfo</a> *<dfn class="decl" id="SessionHandle::cookies" title='SessionHandle::cookies' data-ref="SessionHandle::cookies">cookies</dfn>;  <i>/* the cookies, read from files and servers */</i></td></tr>
<tr><th id="902">902</th><td>  <b>struct</b> <a class="type" href="#Progress" title='Progress' data-ref="Progress">Progress</a> <dfn class="decl" id="SessionHandle::progress" title='SessionHandle::progress' data-ref="SessionHandle::progress">progress</dfn>;    <i>/* for all the progress meter data */</i></td></tr>
<tr><th id="903">903</th><td>  <b>struct</b> <a class="type" href="#UrlState" title='UrlState' data-ref="UrlState">UrlState</a> <dfn class="decl" id="SessionHandle::state" title='SessionHandle::state' data-ref="SessionHandle::state">state</dfn>;       <i>/* struct for fields used for state info and</i></td></tr>
<tr><th id="904">904</th><td><i>                                  other dynamic purposes */</i></td></tr>
<tr><th id="905">905</th><td>  <b>struct</b> <a class="type" href="#PureInfo" title='PureInfo' data-ref="PureInfo">PureInfo</a> <dfn class="decl" id="SessionHandle::info" title='SessionHandle::info' data-ref="SessionHandle::info">info</dfn>;        <i>/* stats, reports and info data */</i></td></tr>
<tr><th id="906">906</th><td><u>#<span data-ppcond="906">if</span> defined(<span class="macro" data-ref="_M/USE_SSLEAY">USE_SSLEAY</span>) &amp;&amp; defined(<span class="macro" data-ref="_M/HAVE_OPENSSL_ENGINE_H">HAVE_OPENSSL_ENGINE_H</span>)</u></td></tr>
<tr><th id="907">907</th><td>  ENGINE*  engine;</td></tr>
<tr><th id="908">908</th><td><u>#<span data-ppcond="906">endif</span> /* USE_SSLEAY */</u></td></tr>
<tr><th id="909">909</th><td>};</td></tr>
<tr><th id="910">910</th><td></td></tr>
<tr><th id="911">911</th><td><u>#define <dfn class="macro" id="_M/LIBCURL_NAME" data-ref="_M/LIBCURL_NAME">LIBCURL_NAME</dfn> "libcurl"</u></td></tr>
<tr><th id="912">912</th><td></td></tr>
<tr><th id="913">913</th><td><u>#<span data-ppcond="1">endif</span></u></td></tr>
<tr><th id="914">914</th><td></td></tr>
</table><hr/><p id='footer'>
Generated while processing <a href='connect.c.html'>codebrowser/curl/lib/connect.c</a><br/>Generated on <em>2017-Aug-29</em> from project codebrowser revision <em>a9c49da</em><br />Powered by <a href='https://woboq.com'><img alt='Woboq' src='https://code.woboq.org/woboq-16.png' width='41' height='16' /></a> <a href='https://code.woboq.org'>Code Browser</a> 2.1
<br/>Generator usage only permitted with license.</p>
</div></body></html>
